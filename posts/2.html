
<!DOCTYPE html>
<html>
<head>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<link href=/style/style.css rel=stylesheet>
<link href=/style/a11y.css rel=stylesheet>
<link href=/favicon.svg rel=icon type=image/svg+xml>
<script src=/scripts/image_loader.js></script>
<script src=/scripts/tikz.js defer></script>
<script src=/scripts/tex-mml-chtml.js defer></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0}}</script>
<title>inefficient business logic</title>
</head>
<body>
<nav class=site-nav id=nav>
<a href=/ >home</a>
<a href=/posts>posts</a>
<a href=/puzzles>puzzles</a>
<div id=lights-container>
<label title="toggle light/dark mode. only persistent with javascript">
<input id=lights type=checkbox>
lights
<script src=/scripts/lights.js></script>
</label>
</div>
</nav>
<div class=template-body>
<noscript class=noscript-warning>
Javascript necessary for displaying LaTeX and TikZ diagrams, and it is also used for other small cosmetic features.
</noscript>
<nav class=posts-nav_top>
<div style="flex:0 0 50%"><a href=/./posts/1>&lt; getting github pages to work the way I want it to</a></div> <div style=text-align:end><a href=/./posts/3>what is an acceptable amount of tech debt &gt;</a></div>
</nav>
<h1 id=inefficient-business-logic>inefficient business logic</h1>
<p>A couple months ago, I was tasked with fixing a deadly performance issue which was in the way of completing one of our larger projects for a client.</p>
<p>I'm not going to get into the technologies behind the project (which I am highly contentious about), but the tldr is that a query generated by the orm was extremely inefficient and the underlying cause was just some inefficient logic by someone.</p>
<h2 id=figuring-out-what-the-hell-is-going-wrong>figuring out what the hell is going wrong</h2>
<p>Fortunately, we had profiling set up so what I was able to find that this was caused due to an sql query which held up the page from loading (page load depending on query is also something I'm questionable about, since I would prefer if the data came in asynchronously)</p>
<p>It boiled down to a several queries formatted like this:</p>
<pre class=code-block><input id=code-block-2-1 type=checkbox><label for=code-block-2-1></label><code><span class=hljs-keyword>SELECT</span>
    tasks1.`id`
<span class=hljs-keyword>FROM</span>
    (
        tasks tasks1
        <span class=hljs-keyword>INNER</span> <span class=hljs-keyword>JOIN</span> companies companies1 <span class=hljs-keyword>ON</span> tasks1.`company` <span class=hljs-operator>=</span> companies1.`id`
    )
<span class=hljs-keyword>WHERE</span>
    tasks1.`type` <span class=hljs-operator>=</span> <span class=hljs-string>&#x27;task_type_1&#x27;</span>
    <span class=hljs-keyword>AND</span> (
        tasks1.`company` <span class=hljs-keyword>IN</span> (
            <span class=hljs-string>&#x27;company1&#x27;</span>,
            <span class=hljs-string>&#x27;company2&#x27;</span>,
            <span class=hljs-string>&#x27;company3&#x27;</span>,
            <span class=hljs-comment>-- literally a billion more ids</span>
        )
    )
    <span class=hljs-keyword>AND</span> companies1.`company_type` <span class=hljs-operator>=</span> <span class=hljs-string>&#x27;company_type_1&#x27;</span>
<span class=hljs-keyword>ORDER</span> <span class=hljs-keyword>BY</span>
    tasks1.`tag`
LIMIT
    <span class=hljs-number>0</span>, <span class=hljs-number>20</span>
</code></pre>
<h3 id=whats-wrong>what's wrong</h3>
<p>Well actually before I looked at the problem, I jokingly said all we had to do was throw another index on the table and everything would most likely be fine. When I looked at this specific query, I noticed that the hangup is most likely in having to search for the tasks by their company column, which didn't have an index on it.</p>
<p>As such, I thought that an index including company on the task table would help, so I made a new composite index on the table and tried running it again. It was still slow - in fact, it was ran under roughly the same amount of time. Why?</p>
<p>I tried running EXPLAIN.</p>
<pre class=code-block><input id=code-block-2-2 type=checkbox><label for=code-block-2-2></label><code>mysql&gt; EXPLAIN (the huge query)
+----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+
| <span class=hljs-built_in>id</span> | select_type | table    | <span class=hljs-built_in>type</span>   | possible_keys     | key     | key_len | ref                    | rows       | Extra                                                 |
+----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+
|  1 | SIMPLE      | tasks1   | ref    | (several indexes) | <span class=hljs-built_in>type</span>    | 243     | const                  | (&gt;500,000) | Using index condition; Using <span class=hljs-built_in>where</span>; Using filesort    |
|  1 | SIMPLE      | company1 | eq_ref | PRIMARY            | PRIMARY | 96      | service.tasks1.company | 1          | Using <span class=hljs-built_in>where</span>                                           |
+----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+
</code></pre>
<p>As we can see, it was not taking advantage of my index at all - for some reason, mysql just decides it's better to not use the index I created. So then I tried forcing the index to be used and got better results.</p>
<pre class=code-block><input id=code-block-2-3 type=checkbox><label for=code-block-2-3></label><code>normal query - 2862.682 ms
forced index - 1514.601 ms
</code></pre>
<p>A 2x speedup with that index - which was good, but actually not good enough as the page still took almost an entire minute to load with a cold cache. The kicker is that there are several of these kinds of queries so overall it still added up.</p>
<h3 id=the-orm>the orm</h3>
<p>This is when I started looking at the code that generated the query. It was something like this:</p>
<pre class=code-block><input id=code-block-2-4 type=checkbox><label for=code-block-2-4></label><code><span class=hljs-comment>// simplified version</span>
private <span class=hljs-keyword>static</span> <span class="hljs-title function_">getType2and3Companies</span>(<span class=hljs-params></span>) {
    <span class=hljs-keyword>const</span> companies = <span class="hljs-title class_">Companies</span>()
        .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;type&#x27;</span>, <span class=hljs-string>&#x27;company_type_2&#x27;</span>)
            .<span class="hljs-title function_">or</span>(<span class=hljs-string>&#x27;type&#x27;</span>, <span class=hljs-string>&#x27;company_type_3&#x27;</span>);
    <span class=hljs-keyword>return</span> [...companies].<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>company</span> =&gt;</span> company.<span class=hljs-property>id</span>);
}

private <span class=hljs-keyword>static</span> <span class="hljs-title function_">getViewableCompanies</span>(<span class=hljs-params>self</span>) {
    <span class=hljs-keyword>const</span> companies = <span class="hljs-title class_">UserToCompany</span>()
        .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;user&#x27;</span>, self.<span class=hljs-property>user</span>)
        .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;company.type&#x27;</span>, <span class=hljs-string>&#x27;company_type_1&#x27;</span>);
    <span class=hljs-keyword>return</span> [...companies].<span class="hljs-title function_">map</span>(<span class=hljs-function><span class=hljs-params>company</span> =&gt;</span> company.<span class=hljs-property>id</span>);
}

public <span class=hljs-keyword>static</span> <span class="hljs-title function_">getViewableRows</span>(<span class=hljs-params>table</span>) {
    <span class=hljs-keyword>const</span> allViewableCompanies = [
        ...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getType2And3Companies</span>(),
        ...<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getViewableCompanies</span>(),
    ];
    <span class=hljs-keyword>switch</span>(table) {
        <span class=hljs-keyword>case</span> <span class=hljs-attr>COMPANY</span>:
            <span class=hljs-keyword>return</span> <span class="hljs-title class_">Companies</span>()
                .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;company.type&#x27;</span>, <span class=hljs-string>&#x27;company_type_1&#x27;</span>);
        <span class=hljs-keyword>case</span> <span class=hljs-attr>EQUIPMENT</span>:
            <span class=hljs-keyword>return</span> <span class="hljs-title class_">Equipment</span>()
                .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;company&#x27;</span>, <span class=hljs-string>&#x27;in&#x27;</span>, allViewableCompanies)
                .<span class="hljs-title function_">and</span>(<span class=hljs-string>&#x27;company.type&#x27;</span>, <span class=hljs-string>&#x27;company_type_1&#x27;</span>)
                .<span class="hljs-title function_">or</span>(<span class=hljs-string>&#x27;type&#x27;</span>, <span class=hljs-string>&#x27;equipment_type_1&#x27;</span>);
        <span class=hljs-keyword>case</span> <span class=hljs-attr>TASKS</span>:
            <span class=hljs-keyword>return</span> <span class="hljs-title class_">Tasks</span>()
                .<span class="hljs-title function_">where</span>(<span class=hljs-string>&#x27;company&#x27;</span>, <span class=hljs-string>&#x27;in&#x27;</span>, allViewableCompanies)
                .<span class="hljs-title function_">and</span>(<span class=hljs-string>&#x27;company.type&#x27;</span>, <span class=hljs-string>&#x27;company_type_1&#x27;</span>);
        <span class=hljs-attr>default</span>:
            <span class=hljs-keyword>throw</span> <span class="hljs-title class_">InvalidTableError</span>();
    }
}
</code></pre>
<p>So the first thought that might cross your mind would be why so many queries when you could do it in one query and some joins? This was just a limitation of the orm being used.</p>
<p>The code is in a working state and nothing is too crazy about it, but it could definitely use some cleaning up here - especially one thing which ended up fixing the problem.</p>
<h3 id=back-to-sql>back to sql</h3>
<p>Now, there are a few things needed to understand why the above query was most likely extremely slow. According to the
<a href=https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in>mysql documentation</a></p>
<blockquote>
<p>If no type conversion is needed for the values in the IN() list, they are all non-JSON constants of the same type, and expr can be compared to each of them as a value of the same type (possibly after type conversion), an optimization takes place. The values the list are sorted and the search for expr is done using a binary search, which makes the IN() operation very quick.</p>
</blockquote>
<p>For our data, we have a lot of tasks and according to EXPLAIN there is basically a sequential search. However, for each task, we would have to perform that binary search for the company on the task, which makes it slow i.e.</p>
<p>Let $m$ be the number of tasks</p>
<p>Let $n$ be the number of companies in the array</p>
<p>The runtime of the query is something like</p>
<p>$$ \begin{align} c_{1} m * c_{2} \log{n} \end{align} $$</p>
<p>Where $c_{1}$ and $c_{2}$ are some constants</p>
<p>Which is actually not too bad in my opinion. We can see that the query itself is bound by the number of tasks or the number of companies in the array, so I set out to cut down one of those. Just as an fyi, tasks are records that would be entered by the users so there's no way to cut that down - which leaves just cutting down the companies.</p>
<h3 id=the-fix>the fix</h3>
<p>Now let's jump back to the code that is generating this query. The important thing to notice here is that at the end of the builder, in the method
<code>getViewableRows</code>, we always filter down the companies to <code>company_type_1</code>. It turns out that an overwhelming majority of companies in the
<code>allViewableCompanies</code> array were of type 2 and 3 but not 1. When I factored that condition out and into a separate method, the array greatly reduced in length and the page was back to loading in a couple of seconds. Wow amazing!</p>
<h2 id=takeaways>takeaways</h2>
<ol>
<li><p>High level abstractions are nice, but each one will have its own strengths and weaknesses. The orm has actually simplified the project a lot and we didn't have to write any sql queries manually, but it ended up hiding a performance issue. Furthermore, in some cases you just won't have the ability to tweak the internals and you will have to toss it and maybe find a replacement.</p></li>
<li><p>Don't write code that just works. Yes, the previous code worked, but was extremely inefficient. This was actually not revealed during testing because the test engineers did not work with such a large set of data when testing (again, maybe a cause of the questionable technologies at play which made this difficult). However, a look over the code might have hinted towards this problem.</p></li>
<li><p>Sometimes an efficiency problem can be fixed by just understanding the business logic and tweaking the internals. You might not need a specialist to look at stuff for you. I'm not really big on sql so fortunately there was a fix I could apply which didn't require much knowledge on that.</p>
<p>Admittedly, I was hoping to use this happening as an argument against the used technologies - everyone knows how much I dislike them since I've been quite tongue-in-cheek about them - but it was fixed so I was unable to complain as much as I wanted to.</p></li>
</ol>
<h2 id=closing>closing</h2>
<p>I'd like to point out that I had noticed the step to improve efficiency and mentioned it as a comment during a code review but it was passed over. Well, I didn't mind because I did not imagine this kind of problem actually popping up so I thought it was more of a micro-optimization if anything and wouldn't matter in the long run.</p>
<p>Then again, the guy that ignored the comment is the kind of person that claimed that sorting data in the code (and not in the database query nor on an indexed field) is better than sorting and sending it client sideâ€¦ for an application that would have a bunch of concurrent users.</p>
<p>It's also important to note that at the end of the day, nothing truly changed aside from some internal calculations. If that array does end up getting extremely large and the performance relapses, I hope I am far away from the project at this time because the technologies behind it are actually trash.</p>
<p>And that's how I <del>saved</del> worked on a multi-million dollar contract <del>from utter doom</del>. Actually there's a story behind how this contract was obtained and some other things about why taking any longer on the delivery might have been extremely bad, but I don't think I'm at liberty to give any details on that.</p>
<nav class=posts-nav_bottom>
<div style="flex:0 0 50%"><a href=/./posts/1>&lt; getting github pages to work the way I want it to</a></div> <div style=text-align:end><a href=/./posts/3>what is an acceptable amount of tech debt &gt;</a></div>
</nav>
<div class=commit-container>
<div class="commit-list de-emphasized">
<span>History:</span>
<details>
<summary>2020-07-14 - make a new post</summary>
<pre class=code-block><input id=code-block-e208ce9668888b3f564f44abcb408714830c40ba-1 type=checkbox><label for=code-block-e208ce9668888b3f564f44abcb408714830c40ba-1></label><code><span class=hljs-meta>@@ -1,2 +1,2 @@</span>
<span class=hljs-deletion>-# don&#x27;t take high level abstractions for granted</span>
<span class=hljs-addition>+# inefficient business logic</span>
</code></pre>
</details>
<details>
<summary>2020-07-07 - fix some typos and grammatical mistakes</summary>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-1 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-1></label><code><span class=hljs-meta>@@ -7,3 +7,4 @@</span> I&#x27;m not going to get into the technologies behind the project (which I am highly
 contentious about), but the tldr is that a query generated by the orm was
<span class=hljs-deletion>-extremely inefficient.</span>
<span class=hljs-addition>+extremely inefficient and the underlying cause was just some inefficient logic</span>
<span class=hljs-addition>+by someone.</span>
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-2 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-2></label><code><span class=hljs-meta>@@ -54,3 +55,3 @@</span> still slow - in fact, it was ran under roughly the same amount of time. Why?

<span class=hljs-deletion>-Then I tried running EXPLAIN.</span>
<span class=hljs-addition>+I tried running EXPLAIN.</span>
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-3 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-3></label><code><span class=hljs-meta>@@ -96,3 +97,3 @@</span> private static getType2and3Companies() {
 private static getViewableCompanies(self) {
<span class=hljs-deletion>-    const companies = UserToCompanies()</span>
<span class=hljs-addition>+    const companies = UserToCompany()</span>
         .where(&#x27;user&#x27;, self.user)
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-4 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-4></label><code><span class=hljs-meta>@@ -130,2 +131,6 @@</span> being used.

<span class=hljs-addition>+The code is in a working state and nothing is too crazy about it, but it could</span>
<span class=hljs-addition>+definitely use some cleaning up here - especially one thing which ended up fixing</span>
<span class=hljs-addition>+the problem.</span>
<span class=hljs-addition>+</span>
 ### back to sql
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-5 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-5></label><code><span class=hljs-meta>@@ -141,3 +146,3 @@</span> extremely slow. According to the [mysql documentation](https://dev.mysql.com/doc

<span class=hljs-deletion>-For our data, we have a lot of tasks and it according to explain there is basically</span>
<span class=hljs-addition>+For our data, we have a lot of tasks and according to EXPLAIN there is basically</span>
 a sequential search. However, for each task, we would have to perform that binary
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-6 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-6></label><code><span class=hljs-meta>@@ -160,3 +165,3 @@</span> bound by the number of tasks or the number of companies in the array, so I set o
 to cut down one of those. Just as an fyi, tasks are records that would be entered
<span class=hljs-deletion>-by the client so there&#x27;s no way to cut that down - which leaves just cutting down</span>
<span class=hljs-addition>+by the users so there&#x27;s no way to cut that down - which leaves just cutting down</span>
 the companies.
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-7 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-7></label><code><span class=hljs-meta>@@ -171,3 +176,3 @@</span> overwheling majority of companies in the `allViewableCompanies` array were of ty
 the array greatly reduced in length and the page was back to loading in a couple
<span class=hljs-deletion>-of seconds.</span>
<span class=hljs-addition>+of seconds. Wow amazing!</span>
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-8 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-8></label><code><span class=hljs-meta>@@ -179,3 +184,3 @@</span> of seconds.
    Furthermore, in some cases you just won&#x27;t have the ability to tweak the internals
<span class=hljs-deletion>-   and you will have to end up heading in another direction.</span>
<span class=hljs-addition>+   and you will have to toss it and maybe find a replacement.</span>
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-9 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-9></label><code><span class=hljs-meta>@@ -184,4 +189,4 @@</span> of seconds.
    did not work with such a large set of data when testing (again, maybe a cause
<span class=hljs-deletion>-   of the questionable technologies at play). However, a look over the code might</span>
<span class=hljs-deletion>-   have hinted towards this problem.</span>
<span class=hljs-addition>+   of the questionable technologies at play which made this difficult). However,</span>
<span class=hljs-addition>+   a look over the code might have hinted towards this problem.</span>
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-10 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-10></label><code><span class=hljs-meta>@@ -204,2 +209,7 @@</span> it was more of a micro-optimization if anything and wouldn&#x27;t matter in the long

<span class=hljs-addition>+Then again, the guy that ignored the comment is the kind of person that claimed</span>
<span class=hljs-addition>+that sorting data in the code (and not in the database query nor on an indexed field)</span>
<span class=hljs-addition>+is better than sorting and sending it client side... for an application that would</span>
<span class=hljs-addition>+have a bunch of concurrent users.</span>
<span class=hljs-addition>+</span>
 It&#x27;s also important to note that at the end of the day, nothing truly changed aside
</code></pre>
<pre class=code-block><input id=code-block-991801c211d44323f9146967db44ff4debf79204-11 type=checkbox><label for=code-block-991801c211d44323f9146967db44ff4debf79204-11></label><code><span class=hljs-meta>@@ -209,5 +219,5 @@</span> because the technologies behind it are actually trash.

<span class=hljs-deletion>-And that&#x27;s how I ~~saved~~ contributed to a multi-million dollar contract ~~from</span>
<span class=hljs-addition>+And that&#x27;s how I ~~saved~~ worked on a multi-million dollar contract ~~from</span>
 utter doom~~. Actually there&#x27;s a story behind how this contract was obtained and
<span class=hljs-deletion>-some other things about why taking any longer on the deliverance might have been</span>
<span class=hljs-addition>+some other things about why taking any longer on the delivery might have been</span>
 extremely bad, but I don&#x27;t think I&#x27;m at liberty to give any details on that.
</code></pre>
</details>
<details>
<summary>2020-07-06 - add the story about performance issues</summary>
<pre class=code-block><input id=code-block-2c25416db83ae5176cc04197c91583bd6852abde-1 type=checkbox><label for=code-block-2c25416db83ae5176cc04197c91583bd6852abde-1></label><code><span class=hljs-meta>@@ -0,0 +1,213 @@</span>
<span class=hljs-addition>+# don&#x27;t take high level abstractions for granted</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+A couple months ago, I was tasked with fixing a deadly performance issue which was</span>
<span class=hljs-addition>+in the way of completing one of our larger projects for a client.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I&#x27;m not going to get into the technologies behind the project (which I am highly</span>
<span class=hljs-addition>+contentious about), but the tldr is that a query generated by the orm was</span>
<span class=hljs-addition>+extremely inefficient.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## figuring out what the hell is going wrong</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Fortunately, we had profiling set up so what I was able to find that this was caused</span>
<span class=hljs-addition>+due to an sql query which held up the page from loading (page load depending on query</span>
<span class=hljs-addition>+is also something I&#x27;m questionable about, since I would prefer if the data came</span>
<span class=hljs-addition>+in asynchronously)</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+It boiled down to a several queries formatted like this:</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+```sql</span>
<span class=hljs-addition>+SELECT</span>
<span class=hljs-addition>+    tasks1.`id`</span>
<span class=hljs-addition>+FROM</span>
<span class=hljs-addition>+    (</span>
<span class=hljs-addition>+        tasks tasks1</span>
<span class=hljs-addition>+        INNER JOIN companies companies1 ON tasks1.`company` = companies1.`id`</span>
<span class=hljs-addition>+    )</span>
<span class=hljs-addition>+WHERE</span>
<span class=hljs-addition>+    tasks1.`type` = &#x27;task_type_1&#x27;</span>
<span class=hljs-addition>+    AND (</span>
<span class=hljs-addition>+        tasks1.`company` IN (</span>
<span class=hljs-addition>+            &#x27;company1&#x27;,</span>
<span class=hljs-addition>+            &#x27;company2&#x27;,</span>
<span class=hljs-addition>+            &#x27;company3&#x27;,</span>
<span class=hljs-addition>+            -- literally a billion more ids</span>
<span class=hljs-addition>+        )</span>
<span class=hljs-addition>+    )</span>
<span class=hljs-addition>+    AND companies1.`company_type` = &#x27;company_type_1&#x27;</span>
<span class=hljs-addition>+ORDER BY</span>
<span class=hljs-addition>+    tasks1.`tag`</span>
<span class=hljs-addition>+LIMIT</span>
<span class=hljs-addition>+    0, 20</span>
<span class=hljs-addition>+```</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### what&#x27;s wrong</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Well actually before I looked at the problem, I jokingly said all we had to do was</span>
<span class=hljs-addition>+throw another index on the table and everything would most likely be fine. When I</span>
<span class=hljs-addition>+looked at this specific query, I noticed that the hangup is most likely in having</span>
<span class=hljs-addition>+to search for the tasks by their company column, which didn&#x27;t have an index on it.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+As such, I thought that an index including company on the task table would help,</span>
<span class=hljs-addition>+so I made a new composite index on the table and tried running it again. It was</span>
<span class=hljs-addition>+still slow - in fact, it was ran under roughly the same amount of time. Why?</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Then I tried running EXPLAIN.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;!-- markdownlint-disable line-length --&gt;</span>
<span class=hljs-addition>+```sh</span>
<span class=hljs-addition>+mysql&gt; EXPLAIN (the huge query)</span>
<span class=hljs-addition>++----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+</span>
<span class=hljs-addition>+| id | select_type | table    | type   | possible_keys     | key     | key_len | ref                    | rows       | Extra                                                 |</span>
<span class=hljs-addition>++----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+</span>
<span class=hljs-addition>+|  1 | SIMPLE      | tasks1   | ref    | (several indexes) | type    | 243     | const                  | (&gt;500,000) | Using index condition; Using where; Using filesort    |</span>
<span class=hljs-addition>+|  1 | SIMPLE      | company1 | eq_ref | PRIMAY            | PRIMARY | 96      | service.tasks1.company | 1          | Using where                                           |</span>
<span class=hljs-addition>++----+-------------+----------+--------+-------------------+---------+---------+------------------------+------------+-------------------------------------------------------+</span>
<span class=hljs-addition>+```</span>
<span class=hljs-addition>+&lt;!-- markdownlint-enable line-length --&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+As we can see, it was not taking advantage of my index at all - for some reason,</span>
<span class=hljs-addition>+mysql just decides it&#x27;s better to not use the index I created. So then I tried</span>
<span class=hljs-addition>+forcing the index to be used and got better results.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+```sh</span>
<span class=hljs-addition>+normal query - 2862.682 ms</span>
<span class=hljs-addition>+forced index - 1514.601 ms</span>
<span class=hljs-addition>+```</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+A 2x speedup with that index - which was good, but actually not good enough as the</span>
<span class=hljs-addition>+page still took almost an entire minute to load with a cold cache. The kicker is</span>
<span class=hljs-addition>+that there are several of these kinds of queries so overall it still added up.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### the orm</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+This is when I started looking at the code that generated the query. It was something</span>
<span class=hljs-addition>+like this:</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+```js</span>
<span class=hljs-addition>+// simplified version</span>
<span class=hljs-addition>+private static getType2and3Companies() {</span>
<span class=hljs-addition>+    const companies = Companies()</span>
<span class=hljs-addition>+        .where(&#x27;type&#x27;, &#x27;company_type_2&#x27;)</span>
<span class=hljs-addition>+            .or(&#x27;type&#x27;, &#x27;company_type_3&#x27;);</span>
<span class=hljs-addition>+    return [...companies].map(company =&gt; company.id);</span>
<span class=hljs-addition>+}</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+private static getViewableCompanies(self) {</span>
<span class=hljs-addition>+    const companies = UserToCompanies()</span>
<span class=hljs-addition>+        .where(&#x27;user&#x27;, self.user)</span>
<span class=hljs-addition>+        .where(&#x27;company.type&#x27;, &#x27;company_type_1&#x27;);</span>
<span class=hljs-addition>+    return [...companies].map(company =&gt; company.id);</span>
<span class=hljs-addition>+}</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+public static getViewableRows(table) {</span>
<span class=hljs-addition>+    const allViewableCompanies = [</span>
<span class=hljs-addition>+        ...this.getType2And3Companies(),</span>
<span class=hljs-addition>+        ...this.getViewableCompanies(),</span>
<span class=hljs-addition>+    ];</span>
<span class=hljs-addition>+    switch(table) {</span>
<span class=hljs-addition>+        case COMPANY:</span>
<span class=hljs-addition>+            return Companies()</span>
<span class=hljs-addition>+                .where(&#x27;company.type&#x27;, &#x27;company_type_1&#x27;);</span>
<span class=hljs-addition>+        case EQUIPMENT:</span>
<span class=hljs-addition>+            return Equipment()</span>
<span class=hljs-addition>+                .where(&#x27;company&#x27;, &#x27;in&#x27;, allViewableCompanies)</span>
<span class=hljs-addition>+                .and(&#x27;company.type&#x27;, &#x27;company_type_1&#x27;)</span>
<span class=hljs-addition>+                .or(&#x27;type&#x27;, &#x27;equipment_type_1&#x27;);</span>
<span class=hljs-addition>+        case TASKS:</span>
<span class=hljs-addition>+            return Tasks()</span>
<span class=hljs-addition>+                .where(&#x27;company&#x27;, &#x27;in&#x27;, allViewableCompanies)</span>
<span class=hljs-addition>+                .and(&#x27;company.type&#x27;, &#x27;company_type_1&#x27;);</span>
<span class=hljs-addition>+        default:</span>
<span class=hljs-addition>+            throw InvalidTableError();</span>
<span class=hljs-addition>+    }</span>
<span class=hljs-addition>+}</span>
<span class=hljs-addition>+```</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+So the first thought that might cross your mind would be why so many queries when</span>
<span class=hljs-addition>+you could do it in one query and some joins? This was just a limitation of the orm</span>
<span class=hljs-addition>+being used.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### back to sql</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Now, there are a few things needed to understand why the above query was most likely</span>
<span class=hljs-addition>+extremely slow. According to the [mysql documentation](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in)</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&gt; If no type conversion is needed for the values in the IN() list, they are all non-JSON</span>
<span class=hljs-addition>+&gt; constants of the same type, and expr can be compared to each of them as a value</span>
<span class=hljs-addition>+&gt; of the same type (possibly after type conversion), an optimization takes place.</span>
<span class=hljs-addition>+&gt; The values the list are sorted and the search for expr is done using a binary</span>
<span class=hljs-addition>+&gt; search, which makes the IN() operation very quick.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+For our data, we have a lot of tasks and it according to explain there is basically</span>
<span class=hljs-addition>+a sequential search. However, for each task, we would have to perform that binary</span>
<span class=hljs-addition>+search for the company on the task, which makes it slow i.e.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Let $m$ be the number of tasks &lt;br /&gt;</span>
<span class=hljs-addition>+Let $n$ be the number of companies in the array &lt;br /&gt;</span>
<span class=hljs-addition>+The runtime of the query is something like</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+c_{1} m * c_{2} \log{n}</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+Where $c_{1}$ and $c_{2}$ are some constants</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Which is actually not too bad in my opinion. We can see that the query itself is</span>
<span class=hljs-addition>+bound by the number of tasks or the number of companies in the array, so I set out</span>
<span class=hljs-addition>+to cut down one of those. Just as an fyi, tasks are records that would be entered</span>
<span class=hljs-addition>+by the client so there&#x27;s no way to cut that down - which leaves just cutting down</span>
<span class=hljs-addition>+the companies.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### the fix</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Now let&#x27;s jump back to the code that is generating this query. The important thing</span>
<span class=hljs-addition>+to notice here is that at the end of the builder, in the method `getViewableRows`,</span>
<span class=hljs-addition>+we always filter down the companies to `company_type_1`. It turns out that an</span>
<span class=hljs-addition>+overwheling majority of companies in the `allViewableCompanies` array were of type</span>
<span class=hljs-addition>+2 and 3 but not 1. When I factored that condition out and into a separate method,</span>
<span class=hljs-addition>+the array greatly reduced in length and the page was back to loading in a couple</span>
<span class=hljs-addition>+of seconds.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## takeaways</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+1. High level abstractions are nice, but each one will have its own strengths and</span>
<span class=hljs-addition>+   weaknesses. The orm has actually simplified the project a lot and we didn&#x27;t have</span>
<span class=hljs-addition>+   to write any sql queries manually, but it ended up hiding a performance issue.</span>
<span class=hljs-addition>+   Furthermore, in some cases you just won&#x27;t have the ability to tweak the internals</span>
<span class=hljs-addition>+   and you will have to end up heading in another direction.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+2. Don&#x27;t write code that just works. Yes, the previous code worked, but was extremely</span>
<span class=hljs-addition>+   inefficent. This was actually not revealed during testing because the test engineers</span>
<span class=hljs-addition>+   did not work with such a large set of data when testing (again, maybe a cause</span>
<span class=hljs-addition>+   of the questionable technologies at play). However, a look over the code might</span>
<span class=hljs-addition>+   have hinted towards this problem.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+3. Sometimes an efficiency problem can be fixed by just understanding the business</span>
<span class=hljs-addition>+   logic and tweaking the internals. You might not need a specialist to look at stuff</span>
<span class=hljs-addition>+   for you. I&#x27;m not really big on sql so fortunately there was a fix I could apply</span>
<span class=hljs-addition>+   which didn&#x27;t require much knowledge on that.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+   Admittedly, I was hoping to use this happening as an argument against the used</span>
<span class=hljs-addition>+   technologies - everyone knows how much I dislike them since I&#x27;ve been quite</span>
<span class=hljs-addition>+   tongue-in-cheek about them - but it was fixed so I was unable to complain as much</span>
<span class=hljs-addition>+   as I wanted to.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## closing</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I&#x27;d like to point out that I had noticed the step to improve efficiency and mentioned</span>
<span class=hljs-addition>+it as a comment during a code review but it was passed over. Well, I didn&#x27;t mind</span>
<span class=hljs-addition>+because I did not imagine this kind of problem actually popping up so I thought</span>
<span class=hljs-addition>+it was more of a micro-optimization if anything and wouldn&#x27;t matter in the long run.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+It&#x27;s also important to note that at the end of the day, nothing truly changed aside</span>
<span class=hljs-addition>+from some internal calculations. If that array does end up getting extremely large</span>
<span class=hljs-addition>+and the performance relapses, I hope I am far away from the project at this time</span>
<span class=hljs-addition>+because the technologies behind it are actually trash.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+And that&#x27;s how I ~~saved~~ contributed to a multi-million dollar contract ~~from</span>
<span class=hljs-addition>+utter doom~~. Actually there&#x27;s a story behind how this contract was obtained and</span>
<span class=hljs-addition>+some other things about why taking any longer on the deliverance might have been</span>
<span class=hljs-addition>+extremely bad, but I don&#x27;t think I&#x27;m at liberty to give any details on that.</span>
</code></pre>
</details>
</div>
</div>
</div>
<picture id=very-cute-picture><img onerror='load_backup_image("/scripts/cozy_reimu.bmp"),load_backup_image("/scripts/unamused_reimu.bmp")' srcset=reimu>
</picture>
</body>
</html>
