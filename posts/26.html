
<!DOCTYPE html>
<html>
<head>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<link href=/style/style.css rel=stylesheet>
<link href=/style/a11y.css rel=stylesheet>
<link href=/favicon.svg rel=icon type=image/svg+xml>
<script src=/scripts/image_loader.js></script>
<script src=/scripts/tikz-loader.js defer></script>
<script src=/scripts/tex-mml-chtml.js defer></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0}}</script>
<title>anonymous anti ddos ideas</title>
</head>
<body>
<nav class=site-nav id=nav>
<a href=/ >home</a>
<a href=/posts>posts</a>
<a href=/puzzles>puzzles</a>
<div id=lights-container>
<label title="toggle light/dark mode. only persistent with javascript">
<input id=lights type=checkbox>
lights
<script src=/scripts/lights.js></script>
</label>
</div>
</nav>
<div class=template-body>
<noscript class=noscript-warning>
Javascript necessary for displaying LaTeX and TikZ diagrams, and it is also used for other small cosmetic features.
</noscript>
<nav class=posts-nav_top>
<div style="flex:0 0 50%"><a href=/./posts/25>&lt; errata 1-24</a></div> <div style=text-align:end><a href=/./posts/27>personal yearly reflection 1 &gt;</a></div>
</nav>
<h1 id=anonymous-anti-ddos-ideas>anonymous anti ddos ideas</h1>
<p>A lot of the stuff I make ends up missing functionality like actual user signup and authentication through some involved process e.g. verifying an email address. If you're running an api and you let people make requests anonymously, then you run a much higher risk of getting ddosed.</p>
<p>I've spent some time yesterday thinking about how to handle this, and came up with a few ideas based on some assumptions. I'll go through them in order, because if one of my assumptions are wrong (due to a lack of understanding or something else), then the entire thing falls apart and you might as well stop reading.</p>
<h2 id=why-is-it-easier-to-ddos-something-without-validation-or-authentication>why is it easier to ddos something without validation or authentication?</h2>
<p>This is the category my stuff falls under - no verification or signups - or at most a very simple sign up with no kind of verification. Every time I write something along the lines of this, I just imagine someone recording the requests, automating them, and hammering my website (unlikely because no one uses my websites).</p>
<p>With validation, users will probably have to have an actual email set up and click a verification link after signing up - this requires a lot more effort than not having it. Admittedly, this part is also automatable somewhat - temporary email addresses are a thing, or you can just have your own domains.</p>
<p>We just need to somehow make the user have to put more effort in when making a request anonymously (whether they know it or not).</p>
<h2 id=problems-that-are-hard-to-solve-but-easy-to-check>problems that are hard to solve but easy to check</h2>
<p>Most (all?) authentication has the server check some provided key to see if it is valid. The key is also generated by the server but only once the user is validated. In our case, we assume there is no validation - so the server just generates a key whenever it's asked for. However, this means that asking for a key is not protected from anonymous requests. This means that we need to move the key generation to the client's side.</p>
<p>We want to make the generation take more effort than normal, but also allow the key to be easily checked by the server to determine if it's valid or not. The first idea that came into my head is something like solving polynomial equations. For humans, solving a polynomial is a little difficulty, but checking the answer just requires plugging it in and checking for equality. I'm not sure if this requires "effort" from a computer, but there are numerical methods to get close approximations which might be good enough to fool the validator so this might not work.</p>
<h3 id=np-complete-problems>NP-complete problems</h3>
<p>It just so happens that NP-complete problems might be what I was looking for - verifiable in polynomial time (relatively quickly), but solvable in a much more complex time.</p>
<p>One of the simplest ones to understand is the boolean satisfiability problem which is where you are given a boolean formula and need to find out whether it can evaluate to true or not. You end up having to true combinations of true and false until you find the solution. When the server receives the proposed solution, checking it is as simple as plugging the solution into the formula.</p>
<p>The main issue with this problem is it's hard to validate if the formula is not satisfiable because that requires checking all combinations, so you want a problem that doesn't have this issue - maybe something like a problem covered by the four color theorem.</p>
<h3 id=captcha>captcha</h3>
<p>I think captchas might be one example of this - proper captchas are hard for computers to solve but easy to validate because the answer is either already determined ahead of time when generated or just depends on what other humans answer, in which case you need a human doing work.</p>
<h3 id=blockchain>blockchain?</h3>
<p>I hate to be that guy (especially when I know nothing about blockchain) but if I understand correctly, there is a lot of processing power when mining crypto - so they must be solving some hard problem, and then they come up with proof of work which is supposedly simple to validate.</p>
<h2 id=guess-at-actual-implementation>guess at actual implementation</h2>
<p>Let's assume we go with the four color theorem approach. What you need is a function that takes in some seed that generates a graph. This function is present on both server/client so the server can also recreate the graph when the client passes the seed and solution. The client then spends time trying to color in the graph and attaches the solution to the request.</p>
<p>The seed should take the current time and data being sent into account so that the generated graph is unique (more or less) to the request. This helps prevent reusing the calculated solution for future requests. Of course, this means the time of the request also has to be sent along - in which case the server would also have to validate the time with the actual time.</p>
<p>What happens if it takes too long to solve the problem? Then the server would most likely discard the request… There are definitely some other things to think about on top of the fact that this might just be a dumb idea - everything is slower, is the validation actually quick enough? It might be possible to have the client slowly calculate various solutions over time and use those for authentication.</p>
<h2 id=conclusion>conclusion</h2>
<p>We shift most of the authentication work to the client. We also take advantage of problems that are hard to find a solution for, but whose solutions are easy to validate to handicap clients from sending too many requests at a time.</p>
<p>Someone's trying to ddos you? Good luck because each request requires solving a specific NP-complete problem tailored to that request.</p>
<p>Is this even a feasible approach? Probably not, but thinking about it was entertaining for me.</p>
<h3 id=later-update>Later update</h3>
<p>I ended up looking at some stuff about proof of work for curiosity's sake and the concept came up around 1993 specifically to combat spam/junk mail… so I guess it supports the idea that this could be a valid countermeasure against ddos attacks. The difference is that emails are sent out much less frequently compared to requests most likely so this approach's effects (takes more computing power) might be more pronounced in this use case.</p>
<p>It's pretty cool when you think up some random ideas only for them to already exist and be implemented in various places.</p>
<nav class=posts-nav_bottom>
<div style="flex:0 0 50%"><a href=/./posts/25>&lt; errata 1-24</a></div> <div style=text-align:end><a href=/./posts/27>personal yearly reflection 1 &gt;</a></div>
</nav>
<div class=commit-container>
<div class="commit-list de-emphasized">
<span>History:</span>
<details>
<summary>2020-11-26 - update 26</summary>
<pre class=code-block><input id=code-block-0c653fb5d3fb7262d2ea744b94ca3a23b33b0e82-1 type=checkbox><label for=code-block-0c653fb5d3fb7262d2ea744b94ca3a23b33b0e82-1></label><code>@@ -106 +106,13 @@ Is this even a feasible approach? Probably not, but thinking about it was entert
 for me.
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### Later update</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I ended up looking at some stuff about proof of work for curiosity&#x27;s sake and the</span>
<span class=hljs-addition>+concept came up around 1993 specifically to combat spam/junk mail... so I guess</span>
<span class=hljs-addition>+it supports the idea that this could be a valid countermeasure against ddos attacks.</span>
<span class=hljs-addition>+The difference is that emails are sent out much less frequently compared to requests</span>
<span class=hljs-addition>+most likely so this approach&#x27;s effects (takes more computing power) might be more</span>
<span class=hljs-addition>+pronounced in this use case.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+It&#x27;s pretty cool when you think up some random ideas only for them to already exist</span>
<span class=hljs-addition>+and be implemented in various places.</span>
</code></pre>
</details>
<details>
<summary>2020-11-26 - 26</summary>
<pre class=code-block><input id=code-block-099d2d5ed6ea50fc64e8c7d5ce235e54147dbc38-1 type=checkbox><label for=code-block-099d2d5ed6ea50fc64e8c7d5ce235e54147dbc38-1></label><code><span class=hljs-meta>@@ -0,0 +1,106 @@</span>
<span class=hljs-addition>+# anonymous anti ddos ideas</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+A lot of the stuff I make ends up missing functionality like actual user signup</span>
<span class=hljs-addition>+and authentication through some involved process e.g. verifying an email address.</span>
<span class=hljs-addition>+If you&#x27;re running an api and you let people make requests anonymously, then you</span>
<span class=hljs-addition>+run a much higher risk of getting ddosed.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I&#x27;ve spent some time yesterday thinking about how to handle this, and came up with</span>
<span class=hljs-addition>+a few ideas based on some assumptions. I&#x27;ll go through them in order, because if</span>
<span class=hljs-addition>+one of my assumptions are wrong (due to a lack of understanding or something else),</span>
<span class=hljs-addition>+then the entire thing falls apart and you might as well stop reading.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## why is it easier to ddos something without validation or authentication?</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+This is the category my stuff falls under - no verification or signups - or</span>
<span class=hljs-addition>+at most a very simple sign up with no kind of verification. Everytime I write something</span>
<span class=hljs-addition>+along the lines of this, I just imagine someone recording the requests, automating</span>
<span class=hljs-addition>+them, and hammering my website (unlikely because no one uses my websites).</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+With validation, users will probably have to have an actual email set up and</span>
<span class=hljs-addition>+click a verification link after signing up - this requires a lot more effort than</span>
<span class=hljs-addition>+not having it. Admittedly, this part is also automatable somewhat - temporary</span>
<span class=hljs-addition>+email addresses are a thing, or you can just have your own domains.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+We just need to somehow make the user have to put more effort in when making a request</span>
<span class=hljs-addition>+anonymously (whether they know it or not).</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## problems that are hard to solve but easy to check</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Most (all?) authentication has the server check some provided key to see if it is</span>
<span class=hljs-addition>+valid. The key is also generated by the server but only once the user is validated.</span>
<span class=hljs-addition>+In our case, we assume there is no validation - so the server just generates a key</span>
<span class=hljs-addition>+whenever it&#x27;s asked for. However, this means that asking for a key is not protected</span>
<span class=hljs-addition>+from anonymous requests. This means that we need to move the key generation to the</span>
<span class=hljs-addition>+client&#x27;s side.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+We want to make the generation take more effort than normal, but also allow the key</span>
<span class=hljs-addition>+to be easily checked by the server to determine if it&#x27;s valid or not. The first idea</span>
<span class=hljs-addition>+that came into my head is something like solving polynomial equations. For humans,</span>
<span class=hljs-addition>+solving a polynomial is a little difficuly, but checking the answer just requires</span>
<span class=hljs-addition>+plugging it in and checking for equality. I&#x27;m not sure if this requires &quot;effort&quot;</span>
<span class=hljs-addition>+from a computer, but there are numerical methods to get close approximations which</span>
<span class=hljs-addition>+might be good enough to fool the validator so this might not work.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### NP-complete problems</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+It just so happens that NP-complete problems might be what I was looking for -</span>
<span class=hljs-addition>+verifiable in polynomial time (relatively quickly), but solvable in a much more complex</span>
<span class=hljs-addition>+time.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+One of the simplest ones to understand is the boolean satisfiablity problem which</span>
<span class=hljs-addition>+is where you are given a boolean formula and need to find out whether it can evaluate</span>
<span class=hljs-addition>+to true or not. You end up having to true combinations of true and false until you</span>
<span class=hljs-addition>+find the solution. When the server recieves the proposed solution, checking it is</span>
<span class=hljs-addition>+as simple as plugging the solution into the formula.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+The main issue with this problem is it&#x27;s hard to validate if the formula is not</span>
<span class=hljs-addition>+satisfiable because that requires checking all combinations, so you want a problem</span>
<span class=hljs-addition>+that doesn&#x27;t have this issue - maybe something like a problem covered by the four</span>
<span class=hljs-addition>+color theorem.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### captcha</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I think captchas might be one example of this - proper captchas are hard for computers</span>
<span class=hljs-addition>+to solve but easy to validate because the answer is either already determined ahead</span>
<span class=hljs-addition>+of time when generated or just depends on what other humans answer, in which case</span>
<span class=hljs-addition>+you need a human doing work.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+### blockchain?</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I hate to be that guy (especially when I know nothing about blockchain) but if I</span>
<span class=hljs-addition>+understand correctly, there is a lot of processing power when mining crypto -</span>
<span class=hljs-addition>+so they must be solving some hard problem, and then they come up with proof of work</span>
<span class=hljs-addition>+which is supposedly simple to validate.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## guess at actual implementation</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Let&#x27;s assume we go with the four color theorem approach. What you need is a function</span>
<span class=hljs-addition>+that takes in some seed that generates a graph. This function is present on both</span>
<span class=hljs-addition>+server/client so the server can also recreate the graph when the client passes the</span>
<span class=hljs-addition>+seed and solution. The client then spends time trying to color in the graph and attaches</span>
<span class=hljs-addition>+the solution to the request.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+The seed should take the current time and data being sent into account so that the</span>
<span class=hljs-addition>+generated graph is unique (more or less) to the request. This helps prevent reusing</span>
<span class=hljs-addition>+the calculated solution for future requests. Of course, this means the time of the</span>
<span class=hljs-addition>+request also has to be sent along - in which case the server would also have to</span>
<span class=hljs-addition>+validate the time with the actual time.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+What happens if it takes too long to solve the problem? Then the server would most</span>
<span class=hljs-addition>+likely discard the request... There are definitely some other things to think about</span>
<span class=hljs-addition>+on top of the fact that this might just be a dumb idea - everything is slower, is</span>
<span class=hljs-addition>+the validation actually quick enough? It might be possible to have the client slowly</span>
<span class=hljs-addition>+calculate various solutions over time and use those for authentication.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## conclusion</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+We shift most of the authentication work to the client. We also take advantage of</span>
<span class=hljs-addition>+problems that are hard to find a solution for, but whose solutions are easy to validate</span>
<span class=hljs-addition>+to handicap clients from sending too many requests at a time.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Someone&#x27;s trying to ddos you? Good luck because each request requires solving a specific</span>
<span class=hljs-addition>+NP-complete problem talored to that request.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+Is this even a feasible approach? Probably not, but thinking about it was entertaining</span>
<span class=hljs-addition>+for me.</span>
</code></pre>
</details>
</div>
</div>
</div>
<picture id=very-cute-picture><img onerror='load_backup_image("/scripts/cozy_reimu.bmp"),load_backup_image("/scripts/unamused_reimu.bmp")' srcset=reimu>
</picture>
</body>
</html>
