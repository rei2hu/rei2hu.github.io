
<!DOCTYPE html>
<html>
<head>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<link href=/style/style.css rel=stylesheet>
<link href=/style/a11y.css rel=stylesheet>
<link href=/favicon.svg rel=icon type=image/svg+xml>
<script src=/scripts/image_loader.js></script>
<script src=/scripts/tikz-loader.js defer></script>
<script src=/scripts/tex-mml-chtml.js defer></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0}}</script>
<title>dynamic programming 1</title>
</head>
<body>
<nav class=site-nav id=nav>
<a href=/ >home</a>
<a href=/posts>posts</a>
<a href=/puzzles>puzzles</a>
<div id=lights-container>
<label title="toggle light/dark mode. only persistent with javascript">
<input id=lights type=checkbox>
lights
<script src=/scripts/lights.js></script>
</label>
</div>
</nav>
<div class=template-body>
<noscript class=noscript-warning>
Javascript necessary for displaying LaTeX and TikZ diagrams, and it is also used for other small cosmetic features.
</noscript>
<nav class=posts-nav_top>
<div style="flex:0 0 50%"></div> <div style=text-align:end><a href=/./puzzles/2>dynamic programming 2 &gt;</a></div>
</nav>
<h1 id=dynamic-programming-1>Dynamic Programming 1</h1>
<h2 id=question-1>Question 1</h2>
<p>Pebbling a checkerboard. We are given a checkerboard which has $4$ rows and $n$ columns, and has an integer written in each square. We are also given a set of $2n$ pebbles, and we want to place some or all of these on the checkerboard (each pebble can be placed on exactly one square) so as to maximize the sum of the integers in the squares that are covered by pebbles. There is one constraint: for a placement of pebbles to be legal, no two of them can be on horizontally or vertically adjacent squares (diagonal adjacency is fine).</p>
<p>(a) Determine the number of legal patterns that can occur in any column (in isolation, ignoring the pebbles in adjacent columns) and describe these patterns.</p>
<p>Pretend the column is a 0-indexed array with length 4. We can place pebbles at the following indices:</p>
<p>$$ [[0, 3], [0, 2], [1, 3], [0], [1], [2], [3], []] $$</p>
<p>Call two patterns compatible if they can be placed on adjacent columns to form a legal placement. Let us consider subproblems consisting of the first $k$ columns $1 \leq k \leq n$. Each subproblem can be assigned a type, which is the pattern occurring in the last column.</p>
<p>A couple of observations to make would be:</p>
<ol>
<li>There are $2n$ pebbles. Because we know that we can put at most $2$ pebbles in each column, we will be able to use any combintion of patterns without running out of pebbles.</li>
<li>It may be correct to use 1 or 0 pebbles in a column because the column may contain negative values. Will taking a negative value open up an avenue for taking a positive value that outweighs the cost? I'm not entirely sure but this doesn't appear to be the case at a glance.</li>
</ol>
<p>(b) Using the notions of compatibility and type, give an $O(n)$-time dynamic programming algorithm for computing an optimal placement</p>
<p>Start by defining a function $f(n, t)$ that expresses the max value that can be obtained for columns $1...n$ by using pattern $t$ on the last column. We can express the function in terms of itself by saying the maximum value for columns $1..n$ and pattern $t$ is the sum of the maximum value for columns $1...n-1$ and the value of applying pattern $t$ to column $n$. We also need the constraint that the pattern for $n-1$ is compatible with $t$. In other words</p>
<p>$$ \begin{align} f(0, t) &= 0 \\ f(n, t) &= \max \{ f(n - 1, t') + val(C_n, t) \mid t' \in compat(t) \} \\ \end{align} $$</p>
<p>Let's try an example:</p>
<p>$$ \begin{bmatrix} 2 & 2 & -5 & 2 & -3 \\ -4 & 1 & 2 & 2 & -1 \\ -1 & 0 & 0 & 3 & -4 \\ 1 & -1 & 3 & -1 & -2 \end{bmatrix} $$</p>
<p>We start with a 2d table, with lengths $N$ and $T$. $T$ is the number of types: 8. We'll label them by their index in the first array we constructed for this problem, and fill out $f(0, t)$, and $f(1, t)$ which is straightforward since we do not need to think about compatibility.</p>
<table>
<thead>
<tr>
<th>n\t</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>1</td>
<td>-3</td>
<td>2</td>
<td>-4</td>
<td>-1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>?</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>â€¦</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>What is $f(2, 0)$? According to our recurrence, it is</p>
<p>$$ \begin{align} f(2, 0) &= \max \{ f(1, t') + val(C_2, 0) \mid t' \in compat(0) \} \\ &= \max \{ f(1, t') + 1 \mid t' \in \{ 1, 3, 4, 7 \} \} \\ &= \max \{ f(1, 1), f(1, 3), f(1, 4), f(1, 7) \} + 1 \\ &= 3 \end{align} $$</p>
<p>The we fill out the table and look for the maximum in the last row for the solution.</p>
<table>
<thead>
<tr>
<th>n\t</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>1</td>
<td>-3</td>
<td>2</td>
<td>-4</td>
<td>-1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>3+1</td>
<td>1+2</td>
<td>2+0</td>
<td>1+2</td>
<td>3+1</td>
<td>3+0</td>
<td>2-1</td>
<td>3+0</td>
</tr>
<tr>
<td>3</td>
<td>4-2</td>
<td>4-5</td>
<td>3+5</td>
<td>4-5</td>
<td>4+2</td>
<td>4+0</td>
<td>4+3</td>
<td>4+0</td>
</tr>
<tr>
<td>4</td>
<td>6+1</td>
<td>8+5</td>
<td>4+1</td>
<td>8+2</td>
<td>7+2</td>
<td>8+3</td>
<td>6-1</td>
<td>8+0</td>
</tr>
<tr>
<td>5</td>
<td>11-5</td>
<td>9-7</td>
<td>13-3</td>
<td>11-3</td>
<td>13-1</td>
<td>10-4</td>
<td>13-2</td>
<td>13+0</td>
</tr>
</tbody>
</table>
<p>I did not check if the table is correct, but we can check if the answer we have is at least valid. We see the max score, 13, is obtained pattern 7, on the last column and work our way backwards. The underlined numbers are the ones chosen.</p>
<p>$$ \begin{bmatrix} 2 & \underline{2} & -5 & \underline{2} & -3 \\ -4 & 1 & \underline{2} & 2 & -1 \\ -1 & 0 & 0 & \underline{3} & -4 \\ \underline{1} & -1 & \underline{3} & -1 & -2 \end{bmatrix} $$</p>
<p>Note that on the second column you can either use pattern 1 or 3, then on the first column you can use 1 or 6.</p>
<h2 id=question-2>Question 2</h2>
<p>Let us define a multiplication operation on three symbols $a$, $b$, $c$ according to the following table; thus $ab = b$, $ba = c$, and so on. Notice that the multiplication operation defined by the table is neither associative nor commutative.</p>
<table>
<thead>
<tr>
<th>\</th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
</tr>
<tr>
<td>b</td>
<td>c</td>
<td>b</td>
<td>a</td>
</tr>
<tr>
<td>c</td>
<td>a</td>
<td>c</td>
<td>c</td>
</tr>
</tbody>
</table>
<p>Find an efficient algorithm that examines a string of these symbols, say $bbbbac$, and decides whether or not it is possible to parenthesize the string in such a way that the value of the resulting expression is $a$. For example, on input $bbbbac$ your algorithm should return yes because $((b(bb))(ba))c = a$.</p>
<p>For this question, we can first note that the we will not be able to define the problem in the $f(n) = f(n - 1)$ kind of way due to the nature of how parenthesization works, namely that it doesn't have to end up like $(((a_1)a_2)a_3)$. This most likely requires a tree like approach.</p>
<p>Start by defining $f(i, j)$ which determines whether or not the substring starting at $a_i$ and ending at $a_j$ equals $a$.</p>
<p>For an expression $a_i, a_{i+1}, ..., a_j$, it is reducible to $a$ if there is some $k \in [i...j]$ where $a_i, ..., a_k$ and $a_{k + 1}, ... a_j$ are reducible to $a$.</p>
<p>$$ \begin{align} f(i, j) &= \max \{ f(i, k)*f(k + 1, j) \mid i \leq k \lt j \} \end{align} $$</p>
<p>I think the weird part with questions like this is determining the actual base cases. If I go with $f(i, i)$ and say it starts at $a_i$ and includes $a_i$, then it is straightforward whether or not a single symbol is $a$ or not. However, if I go one level higher - $f(i, i + 1)$ which could be decomposed into $f(i, i)$ and $f(i + 1, i + 1)$, but even if $f(i, i)$ is false, $f(i, i)*f(i + 1, i + 1)$ may not be, depending on the table.</p>
<p>One alternative is to say $f(i, i)$ starts at $a_i$ but does not include $a_i$. In other words it is empty. This is trivially 0 (false). But then if we have $f(i, i + 1)$ be the symbol $a$, we would then decompose it to $f(i, i)*f(i+1, i+1)$ which is 2 falses.</p>
<p>We end up needing a third argument here. The tree might look like this:</p>
<noscript><pre>\begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, ->]
  \node {x}
    child{ node {y} edge from parent node[left, draw=none] {}}
    child{ node {z} edge from parent node[right, draw=none] {}};
\end{tikzpicture}</pre></noscript>
<script type=text/tikz>\begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, ->]
  \node {x}
    child{ node {y} edge from parent node[left, draw=none] {}}
    child{ node {z} edge from parent node[right, draw=none] {}};
\end{tikzpicture}</script>
<p>If $x$ is the root, we need to determine if $x$ can be $a$. To do this, we need to know possible values for $y$ and $z$. If we go deeper, we can get a subtree rooted at $y$.</p>
<noscript><pre>\begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, ->]
  \node {x}
    child{ node {y}
        child{ node {m} edge from parent node[left, draw=none] {}}
        child{ node {n} edge from parent node[right, draw=none] {}}
        edge from parent node[left, draw=none] {}
    }
    child{ node {z} edge from parent node[right, draw=none] {}};
\end{tikzpicture}</pre></noscript>
<script type=text/tikz>\begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, ->]
  \node {x}
    child{ node {y}
        child{ node {m} edge from parent node[left, draw=none] {}}
        child{ node {n} edge from parent node[right, draw=none] {}}
        edge from parent node[left, draw=none] {}
    }
    child{ node {z} edge from parent node[right, draw=none] {}};
\end{tikzpicture}</script>
<p>At this point, $y$ does not necessarily have to be $a$, as it could be any value as long as the combination of $y$ and $x$ can make $a$. This means the combination of $(mn)x$ should equal $a$. So in addition to having $i$ and $j$, we need another $s$ which determines what are the valid symbols that can be at that position. So we define $f(s, i, j)$ to be if the symbol $s$ can be created from $a_i$ to $a_j$, inclusive.</p>
<p>$$ \begin{align} f(s, i, i) &= a_i == s \\ f(s, i, j) &= s \in \{ m * n \mid n, m \in \{ a, b, c \}, \exists k \in [i, j) \text{ st } f(m, i, k) \text{ and } f(n, k + 1, j) \} \end{align} $$</p>
<p>Long story short, $f(s, i, j)$ is true if $s$ can be made from the children's possibilities. My guess is that we will be calculating the set of possibilities until we reach the root, namely $f(_, 0, len)$ at which point we run $f(a, 0, len)$ for the answer.</p>
<p>But finally to the example - we keep track of the set of possiblities for parenthesizing $a_i$ to $a_j$</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(b)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>(b)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td>(b)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>(b)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(a)</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(c)</td>
</tr>
</tbody>
</table>
<p>Let's run a simple example $f(_, 0, 1)$ for all symbols:</p>
<p>$$ \begin{align} f(a, 0, 1) &= a \in \{ (b *b) \} = false \\ f(b, 0, 1) &= b \in \{ (b* b) \} = true \\ f(c, 0, 1) &= c \in \{ (b * b) \} = false \\ \end{align} $$</p>
<p>So $f(_, 0, 1) = (b)$. Fill out the rest to get this:</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(b)</td>
<td>(b)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>(b)</td>
<td>(b)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td>(b)</td>
<td>(b)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>(b)</td>
<td>(c)</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(a)</td>
<td>(a)</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(c)</td>
</tr>
</tbody>
</table>
<p>Things get more complex on the next level. $f(a, 0, 2)$. We won't follow the formula directly, but we will work around it.</p>
<p>$$ \begin{align} &(n, f(n, k + 1, 2)) \forall k \in [0, 2), n \in \{ a, b, c \} \\ &k = 0, &n = a &\implies &(a, f(a, 1, 2)) &\implies &(a, false) \\ & &n = b &\implies &(b, f(b, 1, 2)) &\implies &(b, true) \\ & &n = c &\implies &(c, f(c, 1, 2)) &\implies &(c, false) \\ &k = 1, &n = a &\implies &(a, f(a, 2, 2)) &\implies &(a, false) \\ & &n = b &\implies &(b, f(b, 2, 2)) &\implies &(b, true) \\ & &n = c &\implies &(c, f(c, 2, 2)) &\implies &(c, false) \\ &(m, f(m, 0, k)) \forall k \in [0, 2), m \in \{ a, b, c \} \\ &k = 0, &m = a &\implies &(a, f(a, 0, 0)) &\implies &(a, false) \\ & &m = b &\implies &(b, f(b, 0, 0)) &\implies &(b, true) \\ & &m = c &\implies &(c, f(c, 0, 0)) &\implies &(c, false) \\ &k = 1, &m = a &\implies &(a, f(a, 0, 1)) &\implies &(a, false) \\ & &m = b &\implies &(b, f(b, 0, 1)) &\implies &(b, true) \\ & &m = c &\implies &(c, f(c, 0, 1)) &\implies &(c, false) \\ \end{align} $$</p>
<p>We get $n \in \{b\}$ and $m \in \{b\}$. Multiplying each element of the sets together gives us $b$, therefore we can only obtain $b$ at this position. Let's try $f(a, 2, 4)$ and $f(c, 2, 4)$ as they are the more interesting ones.</p>
<p>$$ \begin{align} &(n, f(n, k + 1, 4)) \forall k \in [2, 4), n \in \{ a, b, c \} \\ &k = 2, &n = a &\implies &(a, f(a, 3, 4)) &\implies &(a, false) \\ & &n = b &\implies &(b, f(b, 3, 4)) &\implies &(b, false) \\ & &n = c &\implies &(c, f(c, 3, 4)) &\implies &(c, true) \\ &k = 3, &n = a &\implies &(a, f(a, 4, 4)) &\implies &(a, true) \\ & &n = b &\implies &(b, f(b, 4, 4)) &\implies &(b, false) \\ & &n = c &\implies &(c, f(c, 4, 4)) &\implies &(c, false) \\ &(m, f(m, 2, k)) \forall k \in [2, 4), m \in \{ a, b, c \} \\ &k = 2, &m = a &\implies &(a, f(a, 2, 2)) &\implies &(a, false) \\ & &m = b &\implies &(b, f(b, 2, 2)) &\implies &(b, true) \\ & &m = c &\implies &(c, f(c, 2, 2)) &\implies &(c, false) \\ &k = 3, &m = a &\implies &(a, f(a, 2, 3)) &\implies &(a, false) \\ & &m = b &\implies &(b, f(b, 2, 3)) &\implies &(b, true) \\ & &m = c &\implies &(c, f(c, 2, 3)) &\implies &(c, false) \\ \end{align} $$</p>
<p>We get $n \in \{c, a\}$ and $m \in \{b\}$ - finally, something interesting. Make sure to keep track of the order, as this multiplication is not commutative. So we end up with $\{ m*n \mid m \in \{b\}, n \in \{c, a \} \}$. we'll go ahead and fill out the rest of the table below.</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>(b)</td>
<td>(b)</td>
<td>(b)</td>
<td>(b)</td>
<td>(a, c)</td>
<td>(a, c)</td>
</tr>
<tr>
<td>1</td>
<td></td>
<td>(b)</td>
<td>(b)</td>
<td>(b)</td>
<td>(a, c)</td>
<td>(a, c)</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td>(b)</td>
<td>(b)</td>
<td>(a, c)</td>
<td>(a, c)</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td>(b)</td>
<td>(c)</td>
<td>(c)</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(a)</td>
<td>(a)</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>(c)</td>
</tr>
</tbody>
</table>
<p>We can see that the entire string can be reduce to either $a$ or $c$. After filling in the table a bit, I ended up defining a new function $p(i, j)$ which defines the possibilities for the substring $a_i...a_j$ that meshes better with what the table contains.</p>
<p>$$ \begin{align} p(i, i) &= \{a_i\} \\ p(i, j) &= \{m * n \mid m \in p(i, k), n \in p(k + 1, j), i \leq k \lt j \} \\ f(s, i, j) &= s \in p(i, j) \\ \end{align} $$</p>
<p>In fact, I basically followed this simpler formula for filling out the table. It also shows how dynamic programming optimizes builds from smaller subproblems to solve the large one.</p>
<nav class=posts-nav_bottom>
<div style="flex:0 0 50%"></div> <div style=text-align:end><a href=/./puzzles/2>dynamic programming 2 &gt;</a></div>
</nav>
<div class=commit-container>
<div class="commit-list de-emphasized">
<span>History:</span>
<details>
<summary>2020-12-04 - fix some calculations</summary>
<pre class=code-block><input id=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-1 type=checkbox><label for=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-1></label><code><span class=hljs-meta>@@ -91,13 +91,13 @@</span> The we fill out the table and look for the maximum in the last row for the solut

<span class=hljs-deletion>-|  n\t  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |</span>
<span class=hljs-deletion>-| :---: | --- | --- | --- | --- | --- | --- | --- | --- |</span>
<span class=hljs-deletion>-|   0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |</span>
<span class=hljs-deletion>-|   1   | 3   | 1   | -3  | 2   | -4  | -1  | 1   | 0   |</span>
<span class=hljs-deletion>-|   2   | 3   | 3   | 2   | 3   | 4   | 3   | 1   | 3   |</span>
<span class=hljs-deletion>-|   3   | 2   | -1  | 9   | -1  | 5   | 4   | 7   | 4   |</span>
<span class=hljs-deletion>-|   4   | 6   | 14  | 5   | 11  | 9   | 12  | 4   | 9   |</span>
<span class=hljs-deletion>-|   5   | 7   | 2   | 11  | 10  | 13  | 7   | 12  | 14  |</span>
<span class=hljs-addition>+|  n\t  | 0    | 1   | 2    | 3    | 4    | 5    | 6    | 7    |</span>
<span class=hljs-addition>+| :---: | ---- | --- | ---- | ---- | ---- | ---- | ---- | ---- |</span>
<span class=hljs-addition>+|   0   | 0    | 0   | 0    | 0    | 0    | 0    | 0    | 0    |</span>
<span class=hljs-addition>+|   1   | 3    | 1   | -3   | 2    | -4   | -1   | 1    | 0    |</span>
<span class=hljs-addition>+|   2   | 3+1  | 1+2 | 2+0  | 1+2  | 3+1  | 3+0  | 2-1  | 3+0  |</span>
<span class=hljs-addition>+|   3   | 4-2  | 4-5 | 3+5  | 4-5  | 4+2  | 4+0  | 4+3  | 4+0  |</span>
<span class=hljs-addition>+|   4   | 6+1  | 8+5 | 4+1  | 8+2  | 7+2  | 8+3  | 6-1  | 8+0  |</span>
<span class=hljs-addition>+|   5   | 11-5 | 9-7 | 13-3 | 11-3 | 13-1 | 10-4 | 13-2 | 13+0 |</span>

 I did not check if the table is correct, but we can check if the answer we have
<span class=hljs-deletion>-is at least valid. We see the max score, 14, is obtained pattern 7, on the last column</span>
<span class=hljs-addition>+is at least valid. We see the max score, 13, is obtained pattern 7, on the last column</span>
 and work our way backwards. The underlined numbers are the ones chosen.
</code></pre>
<pre class=code-block><input id=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-2 type=checkbox><label for=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-2></label><code><span class=hljs-meta>@@ -106,4 +106,4 @@</span> $$
 \begin{bmatrix}
<span class=hljs-deletion>-  \underline{2}  &amp; 2              &amp; -5            &amp; \underline{2} &amp; -3 \\</span>
<span class=hljs-deletion>-  -4             &amp; \underline{1}  &amp; \underline{2} &amp; 2             &amp; -1 \\</span>
<span class=hljs-addition>+  2              &amp; \underline{2}  &amp; -5            &amp; \underline{2} &amp; -3 \\</span>
<span class=hljs-addition>+  -4             &amp; 1              &amp; \underline{2} &amp; 2             &amp; -1 \\</span>
   -1             &amp; 0              &amp; 0             &amp; \underline{3} &amp; -4 \\
</code></pre>
<pre class=code-block><input id=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-3 type=checkbox><label for=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-3></label><code><span class=hljs-meta>@@ -112,3 +112,4 @@</span> $$
 $$
<span class=hljs-deletion>-We actually picked pattern 7 in the last row because they were all negative.</span>
<span class=hljs-addition>+Note that on the second column you can either use pattern 1 or 3, then on the first</span>
<span class=hljs-addition>+column you can use 1 or 6.</span>
 &lt;/p&gt;
</code></pre>
<pre class=code-block><input id=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-4 type=checkbox><label for=code-block-33e78b9b63dc902355fa5ed524110057a426e7be-4></label><code><span class=hljs-meta>@@ -310,3 +311,4 @@</span> We can see that the entire string can be reduce to either $a$ or $c$. After fill
 in the table a bit, I ended up defining a new function $p(i, j)$ which defines the
<span class=hljs-deletion>-possibilities for the substring $a_i...a_j$ that meshes better with what the table.</span>
<span class=hljs-addition>+possibilities for the substring $a_i...a_j$ that meshes better with what the table</span>
<span class=hljs-addition>+contains.</span>
 $$
</code></pre>
</details>
<details>
<summary>2020-12-04 - add exercises 1</summary>
<pre class=code-block><input id=code-block-c4bd3a03c685e008e1ae316de2d61f7824afe058-1 type=checkbox><label for=code-block-c4bd3a03c685e008e1ae316de2d61f7824afe058-1></label><code><span class=hljs-meta>@@ -0,0 +1,322 @@</span>
<span class=hljs-addition>+&lt;!-- markdownlint-disable MD041 --&gt;</span>
<span class=hljs-addition>+## Question 1</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Pebbling a checkerboard. We are given a checkerboard which has $4$ rows and $n$ columns,</span>
<span class=hljs-addition>+and has an integer written in each square. We are also given a set of $2n$ pebbles,</span>
<span class=hljs-addition>+and we want to place some or all of these on the checkerboard (each pebble can be</span>
<span class=hljs-addition>+placed on exactly one square) so as to maximize the sum of the integers in the squares</span>
<span class=hljs-addition>+that are covered by pebbles. There is one constraint: for a placement of pebbles</span>
<span class=hljs-addition>+to be legal, no two of them can be on horizontally or vertically adjacent squares</span>
<span class=hljs-addition>+(diagonal adjacency is fine).</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+(a) Determine the number of legal patterns that can occur in any column (in isolation,</span>
<span class=hljs-addition>+ignoring the pebbles in adjacent columns) and describe these patterns.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Pretend the column is a 0-indexed array with length 4. We can place pebbles at the</span>
<span class=hljs-addition>+following indices:</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+[[0, 3], [0, 2], [1, 3], [0], [1], [2], [3], []]</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+Call two patterns compatible if they can be placed on adjacent columns to form a</span>
<span class=hljs-addition>+legal placement. Let us consider subproblems consisting of the first $k$ columns</span>
<span class=hljs-addition>+$1 \leq k \leq n$. Each subproblem can be assigned a type, which is the pattern occurring</span>
<span class=hljs-addition>+in the last column.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+A couple of observations to make would be:</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+1. There are $2n$ pebbles. Because we know that we can put at most $2$ pebbles in</span>
<span class=hljs-addition>+   each column, we will be able to use any combintion of patterns without running</span>
<span class=hljs-addition>+   out of pebbles.</span>
<span class=hljs-addition>+2. It may be correct to use 1 or 0 pebbles in a column because the column may contain</span>
<span class=hljs-addition>+   negative values. Will taking a negative value open up an avenue for taking a positive</span>
<span class=hljs-addition>+   value that outweighs the cost? I&#x27;m not entirely sure but this doesn&#x27;t appear to</span>
<span class=hljs-addition>+   be the case at a glance.</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+(b) Using the notions of compatibility and type, give an $O(n)$-time dynamic programming</span>
<span class=hljs-addition>+algorithm for computing an optimal placement</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Start by defining a function $f(n, t)$ that expresses the max value that can be obtained</span>
<span class=hljs-addition>+for columns $1...n$ by using pattern $t$ on the last column. We can express the function</span>
<span class=hljs-addition>+in terms of itself by saying the maximum value for columns $1..n$ and pattern $t$</span>
<span class=hljs-addition>+is the sum of the maximum value for columns $1...n-1$ and the value of applying</span>
<span class=hljs-addition>+pattern $t$ to column $n$. We also need the constraint that the pattern for $n-1$</span>
<span class=hljs-addition>+is compatible with $t$. In other words</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  f(0, t) &amp;= 0 \\</span>
<span class=hljs-addition>+  f(n, t) &amp;= \max \{ f(n - 1, t&#x27;) + val(C_n, t) \mid t&#x27; \in compat(t) \}</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+Let&#x27;s try an example:</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{bmatrix}</span>
<span class=hljs-addition>+  2 &amp; 2 &amp; -5 &amp; 2 &amp; -3 \\</span>
<span class=hljs-addition>+  -4 &amp; 1 &amp; 2 &amp; 2 &amp; -1 \\</span>
<span class=hljs-addition>+  -1 &amp; 0 &amp; 0 &amp; 3 &amp; -4 \\</span>
<span class=hljs-addition>+  1 &amp; -1 &amp; 3 &amp; -1 &amp; -2</span>
<span class=hljs-addition>+\end{bmatrix}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+We start with a 2d table, with lengths $N$ and $T$. $T$ is the number of types:</span>
<span class=hljs-addition>+8. We&#x27;ll label them by their index in the first array we constructed for this problem,</span>
<span class=hljs-addition>+and fill out $f(0, t)$, and $f(1, t)$ which is straightforward since we do not need</span>
<span class=hljs-addition>+to think about compatibility.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  n\t  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- | --- | --- | --- | --- | --- |</span>
<span class=hljs-addition>+|   0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |</span>
<span class=hljs-addition>+|   1   | 3   | 1   | -3  | 2   | -4  | -1  | 1   | 0   |</span>
<span class=hljs-addition>+|   2   | ?   |     |     |     |     |     |     |     |</span>
<span class=hljs-addition>+|  ...  |     |     |     |     |     |     |     |     |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+What is $f(2, 0)$? According to our recurrence, it is</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  f(2, 0) &amp;= \max \{ f(1, t&#x27;) + val(C_2, 0) \mid t&#x27; \in compat(0) \} \\</span>
<span class=hljs-addition>+  &amp;= \max \{ f(1, t&#x27;) + 1 \mid t&#x27; \in \{ 1, 3, 4, 7 \} \} \\</span>
<span class=hljs-addition>+  &amp;= \max \{ f(1, 1), f(1, 3), f(1, 4), f(1, 7) \} + 1 \\</span>
<span class=hljs-addition>+  &amp;= 3</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+The we fill out the table and look for the maximum in the last row for the solution.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  n\t  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- | --- | --- | --- | --- | --- |</span>
<span class=hljs-addition>+|   0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |</span>
<span class=hljs-addition>+|   1   | 3   | 1   | -3  | 2   | -4  | -1  | 1   | 0   |</span>
<span class=hljs-addition>+|   2   | 3   | 3   | 2   | 3   | 4   | 3   | 1   | 3   |</span>
<span class=hljs-addition>+|   3   | 2   | -1  | 9   | -1  | 5   | 4   | 7   | 4   |</span>
<span class=hljs-addition>+|   4   | 6   | 14  | 5   | 11  | 9   | 12  | 4   | 9   |</span>
<span class=hljs-addition>+|   5   | 7   | 2   | 11  | 10  | 13  | 7   | 12  | 14  |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+I did not check if the table is correct, but we can check if the answer we have</span>
<span class=hljs-addition>+is at least valid. We see the max score, 14, is obtained pattern 7, on the last column</span>
<span class=hljs-addition>+and work our way backwards. The underlined numbers are the ones chosen.</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{bmatrix}</span>
<span class=hljs-addition>+  \underline{2}  &amp; 2              &amp; -5            &amp; \underline{2} &amp; -3 \\</span>
<span class=hljs-addition>+  -4             &amp; \underline{1}  &amp; \underline{2} &amp; 2             &amp; -1 \\</span>
<span class=hljs-addition>+  -1             &amp; 0              &amp; 0             &amp; \underline{3} &amp; -4 \\</span>
<span class=hljs-addition>+  \underline{1}  &amp; -1             &amp; \underline{3} &amp; -1            &amp; -2</span>
<span class=hljs-addition>+\end{bmatrix}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+We actually picked pattern 7 in the last row because they were all negative.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+## Question 2</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Let us define a multiplication operation on three symbols $a$, $b$, $c$ according</span>
<span class=hljs-addition>+to the following table; thus $ab = b$, $ba = c$, and so on. Notice that the multiplication</span>
<span class=hljs-addition>+operation defined by the table is neither associative nor commutative.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  \\   | a   | b   | c   |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- |</span>
<span class=hljs-addition>+|   a   | b   | b   | a   |</span>
<span class=hljs-addition>+|   b   | c   | b   | a   |</span>
<span class=hljs-addition>+|   c   | a   | c   | c   |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Find an efficient algorithm that examines a string of these symbols, say $bbbbac$,</span>
<span class=hljs-addition>+and decides whether or not it is possible to parenthesize the string in such a way</span>
<span class=hljs-addition>+that the value of the resulting expression is $a$. For example, on input $bbbbac$</span>
<span class=hljs-addition>+your algorithm should return yes because $((b(bb))(ba))c = a$.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+For this question, we can first note that the we will not be able to define the problem</span>
<span class=hljs-addition>+in the $f(n) = f(n - 1)$ kind of way due to the nature of how parenthesization works,</span>
<span class=hljs-addition>+namely that it doesn&#x27;t have to end up like $(((a_1)a_2)a_3)$. This most likely requires</span>
<span class=hljs-addition>+a tree like approach.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Start by defining $f(i, j)$ which determines whether or not the substring starting</span>
<span class=hljs-addition>+at $a_i$ and ending at $a_j$ equals $a$.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+For an expression $a_i, a_{i+1}, ..., a_j$, it is reducible to $a$ if there is some</span>
<span class=hljs-addition>+$k \in [i...j]$ where $a_i, ..., a_k$ and $a_{k + 1}, ... a_j$ are reducible to $a$.</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  f(i, j) &amp;= \max \{ f(i, k)*f(k + 1, j) \mid i \leq k \lt j \}</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+I think the weird part with questions like this is determining the actual base cases.</span>
<span class=hljs-addition>+If I go with $f(i, i)$ and say it starts at $a_i$ and includes $a_i$, then it is</span>
<span class=hljs-addition>+straightforward whether or not a single symbol is $a$ or not. However, if I go one</span>
<span class=hljs-addition>+level higher - $f(i, i + 1)$ which could be decomposed into $f(i, i)$ and</span>
<span class=hljs-addition>+$f(i + 1, i + 1)$, but even if $f(i, i)$ is false, $f(i, i)*f(i + 1, i + 1)$ may</span>
<span class=hljs-addition>+not be, depending on the table.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+One alternative is to say $f(i, i)$ starts at $a_i$ but does not include $a_i$.</span>
<span class=hljs-addition>+In other words it is empty. This is trivially 0 (false). But then if we have</span>
<span class=hljs-addition>+$f(i, i + 1)$ be the symbol $a$, we would then decompose it to $f(i, i)*f(i+1, i+1)$</span>
<span class=hljs-addition>+which is 2 falses.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+We end up needing a third argument here. The tree might look like this:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node {x}</span>
<span class=hljs-addition>+      child{ node {y} edge from parent node[left, draw=none] {}}</span>
<span class=hljs-addition>+      child{ node {z} edge from parent node[right, draw=none] {}};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+If $x$ is the root, we need to determine if $x$ can be $a$. To do this, we need</span>
<span class=hljs-addition>+to know possible values for $y$ and $z$. If we go deeper, we can get a subtree rooted</span>
<span class=hljs-addition>+at $y$.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node {x}</span>
<span class=hljs-addition>+      child{ node {y}</span>
<span class=hljs-addition>+          child{ node {m} edge from parent node[left, draw=none] {}}</span>
<span class=hljs-addition>+          child{ node {n} edge from parent node[right, draw=none] {}}</span>
<span class=hljs-addition>+          edge from parent node[left, draw=none] {}</span>
<span class=hljs-addition>+      }</span>
<span class=hljs-addition>+      child{ node {z} edge from parent node[right, draw=none] {}};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+At this point, $y$ does not necessarily have to be $a$, as it could be any value</span>
<span class=hljs-addition>+as long as the combination of $y$ and $x$ can make $a$. This means the combination</span>
<span class=hljs-addition>+of $(mn)x$ should equal $a$. So in addition to having $i$ and $j$, we need another</span>
<span class=hljs-addition>+$s$ which determines what are the valid symbols that can be at that position. So</span>
<span class=hljs-addition>+we define $f(s, i, j)$ to be if the symbol $s$ can be created from $a_i$ to $a_j$,</span>
<span class=hljs-addition>+inclusive.</span>
<span class=hljs-addition>+&lt;!-- markdownlint-disable MD013 --&gt;</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  f(s, i, i) &amp;= a_i == s \\</span>
<span class=hljs-addition>+  f(s, i, j) &amp;= s \in \{ m * n \mid n, m \in \{ a, b, c \}, \exists k \in [i, j) \text{ st } f(m, i, k) \text{ and } f(n, k + 1, j) \}</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+&lt;!-- markdownlint-enable MD013 --&gt;</span>
<span class=hljs-addition>+Long story short, $f(s, i, j)$ is true if $s$ can be made from the children&#x27;s possibilities.</span>
<span class=hljs-addition>+My guess is that we will be calculating the set of possibilities until we reach</span>
<span class=hljs-addition>+the root, namely $f(_, 0, len)$ at which point we run $f(a, 0, len)$ for the answer.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+But finally to the example - we keep track of the set of possiblities for parenthesizing</span>
<span class=hljs-addition>+$a_i$ to $a_j$</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  i\j  | 0   | 1   | 2   | 3   | 4   | 5   |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- | --- | --- | --- |</span>
<span class=hljs-addition>+|   0   | (b) |     |     |     |     |     |</span>
<span class=hljs-addition>+|   1   |     | (b) |     |     |     |     |</span>
<span class=hljs-addition>+|   2   |     |     | (b) |     |     |     |</span>
<span class=hljs-addition>+|   3   |     |     |     | (b) |     |     |</span>
<span class=hljs-addition>+|   4   |     |     |     |     | (a) |     |</span>
<span class=hljs-addition>+|   5   |     |     |     |     |     | (c) |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Let&#x27;s run a simple example $f(_, 0, 1)$ for all symbols:</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  f(a, 0, 1) &amp;= a \in \{ (b * b) \} = false \\</span>
<span class=hljs-addition>+  f(b, 0, 1) &amp;= b \in \{ (b * b) \} = true \\</span>
<span class=hljs-addition>+  f(c, 0, 1) &amp;= c \in \{ (b * b) \} = false \\</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+So $f(_, 0, 1) = (b)$. Fill out the rest to get this:</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  i\j  | 0   | 1   | 2   | 3   | 4   | 5   |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- | --- | --- | --- |</span>
<span class=hljs-addition>+|   0   | (b) | (b) |     |     |     |     |</span>
<span class=hljs-addition>+|   1   |     | (b) | (b) |     |     |     |</span>
<span class=hljs-addition>+|   2   |     |     | (b) | (b) |     |     |</span>
<span class=hljs-addition>+|   3   |     |     |     | (b) | (c) |     |</span>
<span class=hljs-addition>+|   4   |     |     |     |     | (a) | (a) |</span>
<span class=hljs-addition>+|   5   |     |     |     |     |     | (c) |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+Things get more complex on the next level. $f(a, 0, 2)$. We won&#x27;t follow the formula</span>
<span class=hljs-addition>+directly, but we will work around it.</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  &amp;(n, f(n, k + 1, 2)) \forall k \in [0, 2), n \in \{ a, b, c \} \\</span>
<span class=hljs-addition>+  &amp;k = 0, &amp;n = a &amp;\implies &amp;(a, f(a, 1, 2)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = b &amp;\implies &amp;(b, f(b, 1, 2)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = c &amp;\implies &amp;(c, f(c, 1, 2)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+  &amp;k = 1, &amp;n = a &amp;\implies &amp;(a, f(a, 2, 2)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = b &amp;\implies &amp;(b, f(b, 2, 2)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = c &amp;\implies &amp;(c, f(c, 2, 2)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+  &amp;(m, f(m, 0, k)) \forall k \in [0, 2), m \in \{ a, b, c \} \\</span>
<span class=hljs-addition>+  &amp;k = 0, &amp;m = a &amp;\implies &amp;(a, f(a, 0, 0)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = b &amp;\implies &amp;(b, f(b, 0, 0)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = c &amp;\implies &amp;(c, f(c, 0, 0)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+  &amp;k = 1, &amp;m = a &amp;\implies &amp;(a, f(a, 0, 1)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = b &amp;\implies &amp;(b, f(b, 0, 1)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = c &amp;\implies &amp;(c, f(c, 0, 1)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+We get $n \in \{b\}$ and $m \in \{b\}$. Multiplying each element of the sets together</span>
<span class=hljs-addition>+gives us $b$, therefore we can only obtain $b$ at this position. Let&#x27;s try $f(a,</span>
<span class=hljs-addition>+2, 4)$ and $f(c, 2, 4)$ as they are the more interesting ones.</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  &amp;(n, f(n, k + 1, 4)) \forall k \in [2, 4), n \in \{ a, b, c \} \\</span>
<span class=hljs-addition>+  &amp;k = 2, &amp;n = a &amp;\implies &amp;(a, f(a, 3, 4)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = b &amp;\implies &amp;(b, f(b, 3, 4)) &amp;\implies &amp;(b, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = c &amp;\implies &amp;(c, f(c, 3, 4)) &amp;\implies &amp;(c, true) \\</span>
<span class=hljs-addition>+  &amp;k = 3, &amp;n = a &amp;\implies &amp;(a, f(a, 4, 4)) &amp;\implies &amp;(a, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = b &amp;\implies &amp;(b, f(b, 4, 4)) &amp;\implies &amp;(b, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;n = c &amp;\implies &amp;(c, f(c, 4, 4)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+  &amp;(m, f(m, 2, k)) \forall k \in [2, 4), m \in \{ a, b, c \} \\</span>
<span class=hljs-addition>+  &amp;k = 2, &amp;m = a &amp;\implies &amp;(a, f(a, 2, 2)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = b &amp;\implies &amp;(b, f(b, 2, 2)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = c &amp;\implies &amp;(c, f(c, 2, 2)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+  &amp;k = 3, &amp;m = a &amp;\implies &amp;(a, f(a, 2, 3)) &amp;\implies &amp;(a, false) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = b &amp;\implies &amp;(b, f(b, 2, 3)) &amp;\implies &amp;(b, true) \\</span>
<span class=hljs-addition>+  &amp;       &amp;m = c &amp;\implies &amp;(c, f(c, 2, 3)) &amp;\implies &amp;(c, false) \\</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+We get $n \in \{c, a\}$ and $m \in \{b\}$ - finally, something interesting.</span>
<span class=hljs-addition>+Make sure to keep track of the order, as this multiplication is not commutative.</span>
<span class=hljs-addition>+So we end up with $\{ m*n \mid m \in \{b\}, n \in \{c, a \} \}$. we&#x27;ll go ahead and</span>
<span class=hljs-addition>+fill out the rest of the table below.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  i\j  | 0   | 1   | 2   | 3   | 4      | 5      |</span>
<span class=hljs-addition>+| :---: | --- | --- | --- | --- | ------ | ------ |</span>
<span class=hljs-addition>+|   0   | (b) | (b) | (b) | (b) | (a, c) | (a, c) |</span>
<span class=hljs-addition>+|   1   |     | (b) | (b) | (b) | (a, c) | (a, c) |</span>
<span class=hljs-addition>+|   2   |     |     | (b) | (b) | (a, c) | (a, c) |</span>
<span class=hljs-addition>+|   3   |     |     |     | (b) | (c)    | (c)    |</span>
<span class=hljs-addition>+|   4   |     |     |     |     | (a)    | (a)    |</span>
<span class=hljs-addition>+|   5   |     |     |     |     |        | (c)    |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+We can see that the entire string can be reduce to either $a$ or $c$. After filling</span>
<span class=hljs-addition>+in the table a bit, I ended up defining a new function $p(i, j)$ which defines the</span>
<span class=hljs-addition>+possibilities for the substring $a_i...a_j$ that meshes better with what the table.</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  p(i, i) &amp;= \{a_i\} \\</span>
<span class=hljs-addition>+  p(i, j) &amp;= \{m * n \mid m \in p(i, k), n \in p(k + 1, j), i \leq k \lt j \} \\</span>
<span class=hljs-addition>+  f(s, i, j) &amp;= s \in p(i, j)</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+In fact, I basically followed this simpler formula for filling out the table. It</span>
<span class=hljs-addition>+also shows how dynamic programming optimizes builds from smaller subproblems to solve</span>
<span class=hljs-addition>+the large one.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
</code></pre>
</details>
</div>
</div>
</div>
<picture id=very-cute-picture><img onerror='load_backup_image("/scripts/cozy_reimu.bmp"),load_backup_image("/scripts/unamused_reimu.bmp")' srcset=reimu>
</picture>
</body>
</html>
