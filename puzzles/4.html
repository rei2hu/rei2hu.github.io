
<!DOCTYPE html>
<html>
<head>
<meta charset=UTF-8>
<meta content="width=device-width,initial-scale=1" name=viewport>
<link href=/style/style.css rel=stylesheet>
<link href=/style/a11y.css rel=stylesheet>
<link href=/favicon.svg rel=icon type=image/svg+xml>
<script src=/scripts/image_loader.js></script>
<script src=/scripts/tex-mml-chtml.js defer></script>
<script>window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0}}</script>
<title>dynamic programming 3</title>
</head>
<body>
<nav class=site-nav id=nav>
<a href=/ >home</a>
<a href=/posts>posts</a>
<a href=/puzzles>puzzles</a>
<div id=lights-container>
<label title="toggle light/dark mode. only persistent with javascript">
<input id=lights type=checkbox>
lights
<script src=/scripts/lights.js></script>
</label>
</div>
</nav>
<div class=template-body>
<noscript class=noscript-warning>
Javascript is necessary for displaying LaTeX, some demos that run algorithms directly on the page, and small cosmetic features like light/dark mode.
</noscript>
<nav class=posts-nav_top>
<div class=posts-nav_before><a href=/./puzzles/3>&lt; randomized algorithms 1</a></div> <div class=posts-nav_after><a href=/./puzzles/5>divide and conquer 1 &gt;</a></div>
</nav>
<h1 id=dynamic-programming-3>Dynamic Programming 3</h1>
<h2 id=question-1>Question 1</h2>
<p>A certain string-processing language offers a primitive operation which splits a string into two pieces. Since this operation involves copying the original string, it takes $n$ units of time for a string of length $n$, regardless of the location of the cut. Suppose, now, that you want to break a string into many pieces. The order in which the breaks are made can affect the total running time. For example, if you want to cut a 20-character string at positions 3 and 10, then making the first cut at position 3 incurs a total cost of 20 + 17 = 37, while doing position 10 first has a better cost of 20 + 10 = 30.</p>
<p>Give a dynamic programming algorithm that, given the locations of $m$ cuts in a string of length $n$, finds the minimum cost of breaking the string into $m + 1$ pieces.</p>
<p>So, I can't think of a formula off the top of my head, and I'm not fully sure how the tree (I assume it's a tree approach) will look. However, let's try working the problem backwards; we have $m + 1$ substrings in order and we want to join them together while minimizing this cost. The cost to join 2 substrings $m_i$ and $m_{i + 1}$ is $\text{len}(m_i) + \text{len}(m_{i + 1})$. In this scenario, the cut locations are baked into the lengths of the substrings. Let's try it out on the example:</p>
<p>We have substrings of length 3, 7, and 10 because we have cuts at 3 and 10 and a total length of 20. It looks something like this:</p>
<p>
</p><div class=tikz-picture style=height:21.73953pt>
<svg height=21.73953pt viewBox="-72 -72 78.64502 21.73953" width=78.64502pt><g transform="translate(-61.40023803710936,-61.40023803710936) scale(1,-1)"><g> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g stroke-width=0.4pt> <g> <g> <path d=" M  10.66977 0.0 C  10.66977 5.89282 5.89282 10.66977 0.0 10.66977 C  -5.89282 10.66977 -10.66977 5.89282 -10.66977 0.0 C  -10.66977 -5.89282 -5.89282 -10.66977 0.0 -10.66977 C  5.89282 -10.66977 10.66977 -5.89282 10.66977 0.0 Z M  0.0 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-2.5,-3.22221)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-61.40023803710936,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-61.40023803710936 y=-61.40023803710936>3</text></g></g> </g> </g> </g> </g> <g> <path d=" M  39.12251 0.0 C  39.12251 5.89282 34.34557 10.66977 28.45274 10.66977 C  22.55992 10.66977 17.78297 5.89282 17.78297 0.0 C  17.78297 -5.89282 22.55992 -10.66977 28.45274 -10.66977 C  34.34557 -10.66977 39.12251 -5.89282 39.12251 0.0 Z M  28.45274 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,25.95274,-3.22221)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-61.40023803710936,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-61.40023803710936 y=-61.40023803710936>7</text></g></g> </g> </g> </g> </g> <g> <path d=" M  67.57526 0.0 C  67.57526 5.89282 62.79831 10.66977 56.90549 10.66977 C  51.01266 10.66977 46.23572 5.89282 46.23572 0.0 C  46.23572 -5.89282 51.01266 -10.66977 56.90549 -10.66977 C  62.79831 -10.66977 67.57526 -5.89282 67.57526 0.0 Z M  56.90549 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,51.90547,-3.22221)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-61.40023803710936,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-61.40023803710936 y=-61.40023803710936>10</text></g></g> </g> </g> </g> </g> </g> </g> </g> </g> </g> </g></svg>
</div>
<p></p>
<p>And we are looking for a way to join them. It is important to note that only neighboring nodes can be joined. We have two choices at this moment:</p>
<p>
</p><div class=tikz-picture style=height:64.41866pt>
<svg height=64.41866pt viewBox="-72 -72 92.87164 64.41866" width=92.87164pt><g transform="translate(-40.06045532226562,-61.40023803710936) scale(1,-1)"><g> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g stroke-width=0.4pt> <g> <g> <path d=" M  10.66977 0.0 C  10.66977 5.89282 5.89282 10.66977 0.0 10.66977 C  -5.89282 10.66977 -10.66977 5.89282 -10.66977 0.0 C  -10.66977 -5.89282 -5.89282 -10.66977 0.0 -10.66977 C  5.89282 -10.66977 10.66977 -5.89282 10.66977 0.0 Z M  0.0 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-5.00002,-3.22221)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-40.06045532226562 y=-61.40023803710936>10</text></g></g> </g> </g> </g> </g> <g> <g> <path d=" M  -10.66977 -42.67912 C  -10.66977 -36.7863 -15.44672 -32.00935 -21.33954 -32.00935 C  -27.23236 -32.00935 -32.00931 -36.7863 -32.00931 -42.67912 C  -32.00931 -48.57195 -27.23236 -53.34889 -21.33954 -53.34889 C  -15.44672 -53.34889 -10.66977 -48.57195 -10.66977 -42.67912 Z M  -21.33954 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-23.83954,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-40.06045532226562 y=-61.40023803710936>3</text></g></g> </g> </g> </g> </g> <path d=" M  -4.8615 -9.72218 L  -16.272 -32.54388  " style=fill:none /> <g> <g transform=matrix(-0.44899,-0.898,0.898,-0.44899,-16.272,-32.54387)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-21.53978,-21.33955)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <g> <path d=" M  32.00935 -42.67912 C  32.00935 -36.7863 27.2324 -32.00935 21.33958 -32.00935 C  15.44676 -32.00935 10.66982 -36.7863 10.66982 -42.67912 C  10.66982 -48.57195 15.44676 -53.34889 21.33958 -53.34889 C  27.2324 -53.34889 32.00935 -48.57195 32.00935 -42.67912 Z M  21.33958 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,18.83958,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-40.06045532226562 y=-61.40023803710936>7</text></g></g> </g> </g> </g> </g> <path d=" M  4.8615 -9.72218 L  16.27205 -32.54388  " style=fill:none /> <g> <g transform=matrix(0.44899,-0.898,0.898,0.44899,16.27205,-32.54387)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,21.5398,-21.33955)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <path d=" M  60.4621 -42.67912 C  60.4621 -36.7863 55.68515 -32.00935 49.79233 -32.00935 C  43.8995 -32.00935 39.12256 -36.7863 39.12256 -42.67912 C  39.12256 -48.57195 43.8995 -53.34889 49.79233 -53.34889 C  55.68515 -53.34889 60.4621 -48.57195 60.4621 -42.67912 Z M  49.79233 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,44.79231,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-40.06045532226562,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-40.06045532226562 y=-61.40023803710936>10</text></g></g> </g> </g> </g> </g> </g> </g> </g> </g> </g> </g></svg>
</div>
<p></p>
<p>And</p>
<p>
</p><div class=tikz-picture style=height:64.41866pt>
<svg height=64.41866pt viewBox="-72 -72 92.87161 64.41866" width=92.87161pt><g transform="translate(-11.607955932617186,-61.40023803710936) scale(1,-1)"><g> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g stroke-width=0.4pt> <g> <g> <path d=" M  10.66977 0.0 C  10.66977 5.89282 5.89282 10.66977 0.0 10.66977 C  -5.89282 10.66977 -10.66977 5.89282 -10.66977 0.0 C  -10.66977 -5.89282 -5.89282 -10.66977 0.0 -10.66977 C  5.89282 -10.66977 10.66977 -5.89282 10.66977 0.0 Z M  0.0 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-5.00002,-3.22221)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-11.607955932617186 y=-61.40023803710936>17</text></g></g> </g> </g> </g> </g> <g> <g> <path d=" M  -10.66977 -42.67912 C  -10.66977 -36.7863 -15.44672 -32.00935 -21.33954 -32.00935 C  -27.23236 -32.00935 -32.00931 -36.7863 -32.00931 -42.67912 C  -32.00931 -48.57195 -27.23236 -53.34889 -21.33954 -53.34889 C  -15.44672 -53.34889 -10.66977 -48.57195 -10.66977 -42.67912 Z M  -21.33954 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-23.83954,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-11.607955932617186 y=-61.40023803710936>7</text></g></g> </g> </g> </g> </g> <path d=" M  -4.8615 -9.72218 L  -16.272 -32.54388  " style=fill:none /> <g> <g transform=matrix(-0.44899,-0.898,0.898,-0.44899,-16.272,-32.54387)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-21.53978,-21.33955)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <g> <path d=" M  32.00935 -42.67912 C  32.00935 -36.7863 27.2324 -32.00935 21.33958 -32.00935 C  15.44676 -32.00935 10.66982 -36.7863 10.66982 -42.67912 C  10.66982 -48.57195 15.44676 -53.34889 21.33958 -53.34889 C  27.2324 -53.34889 32.00935 -48.57195 32.00935 -42.67912 Z M  21.33958 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,16.33957,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-11.607955932617186 y=-61.40023803710936>10</text></g></g> </g> </g> </g> </g> <path d=" M  4.8615 -9.72218 L  16.27205 -32.54388  " style=fill:none /> <g> <g transform=matrix(0.44899,-0.898,0.898,0.44899,16.27205,-32.54387)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,21.5398,-21.33955)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <path d=" M  -39.12251 -42.67912 C  -39.12251 -36.7863 -43.89946 -32.00935 -49.79228 -32.00935 C  -55.6851 -32.00935 -60.46205 -36.7863 -60.46205 -42.67912 C  -60.46205 -48.57195 -55.6851 -53.34889 -49.79228 -53.34889 C  -43.89946 -53.34889 -39.12251 -48.57195 -39.12251 -42.67912 Z M  -49.79228 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-52.29228,-45.90134)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-11.607955932617186,-61.40023803710936) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-11.607955932617186 y=-61.40023803710936>3</text></g></g> </g> </g> </g> </g> </g> </g> </g> </g> </g> </g></svg>
</div>
<p></p>
<p>We can also see various base cases here - when there is only 1 substring. However, one thing to note is that we also need to keep track of the total cost to reach that stage. If we were to go one step higher and reach 20, we realize that 20 is not the cost but rather the cost of the last step. Let's see the example but we also keep track of the cost:</p>
<p>
</p><div class=tikz-picture style=height:124.96674pt>
<svg height=124.96674pt viewBox="-72 -72 101.2563 124.96674" width=101.2563pt><g transform="translate(-12.085510253906246,-50.166931152343736) scale(1,-1)"><g> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g stroke-width=0.4pt> <g> <g> <path d=" M  21.90308 0.0 C  21.90308 12.09688 12.09688 21.90308 0.0 21.90308 C  -12.09688 21.90308 -21.90308 12.09688 -21.90308 0.0 C  -21.90308 -12.09688 -12.09688 -21.90308 0.0 -21.90308 C  12.09688 -21.90308 21.90308 -12.09688 21.90308 0.0 Z M  0.0 0.0  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-16.94449,-2.5)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-12.085510253906246 y=-50.166931152343736>(20,</text><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=7.9145450592041 y=-50.166931152343736>30)</text></g></g> </g> </g> </g> </g> <g> <g> <path d=" M  0.56354 -42.67912 C  0.56354 -30.58224 -9.24266 -20.77605 -21.33954 -20.77605 C  -33.43642 -20.77605 -43.24261 -30.58224 -43.24261 -42.67912 C  -43.24261 -54.776 -33.43642 -64.5822 -21.33954 -64.5822 C  -9.24266 -64.5822 0.56354 -54.776 0.56354 -42.67912 Z M  -21.33954 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-38.28403,-45.17912)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-12.085510253906246 y=-50.166931152343736>(10,</text><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=7.9145450592041 y=-50.166931152343736>10)</text></g></g> </g> </g> </g> </g> <path d=" M  -9.88527 -19.76952 L  -11.24847 -22.49655  " style=fill:none /> <g> <g transform=matrix(-0.44891,-0.898,0.898,-0.44891,-11.24846,-22.49654)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <path d=" M  -25.37366 -85.35825 C  -25.37366 -75.80061 -33.12144 -68.05283 -42.67908 -68.05283 C  -52.23671 -68.05283 -59.9845 -75.80061 -59.9845 -85.35825 C  -59.9845 -94.91588 -52.23671 -102.66367 -42.67908 -102.66367 C  -33.12144 -102.66367 -25.37366 -94.91588 -25.37366 -85.35825 Z M  -42.67908 -85.35825  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-54.62355,-87.85825)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-12.085510253906246 y=-50.166931152343736>(3,</text><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=2.914525985717773 y=-50.166931152343736>0)</text></g></g> </g> </g> </g> </g> <path d=" M  -31.22446 -62.44864 L  -34.64407 -69.28792  " style=fill:none /> <g> <g transform=matrix(-0.44897,-0.898,0.898,-0.44897,-34.64407,-69.2879)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-43.90729,-66.0748)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <g> <path d=" M  17.30547 -85.35825 C  17.30547 -75.80061 9.55768 -68.05283 0.00005 -68.05283 C  -9.55759 -68.05283 -17.30537 -75.80061 -17.30537 -85.35825 C  -17.30537 -94.91588 -9.55759 -102.66367 0.00005 -102.66367 C  9.55768 -102.66367 17.30547 -94.91588 17.30547 -85.35825 Z M  0.00005 -85.35825  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-11.94443,-87.85825)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-12.085510253906246 y=-50.166931152343736>(7,</text><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=2.914525985717773 y=-50.166931152343736>0)</text></g></g> </g> </g> </g> </g> <path d=" M  -11.45462 -62.44864 L  -8.03497 -69.28792  " style=fill:none /> <g> <g transform=matrix(0.44899,-0.898,0.898,0.44899,-8.03497,-69.2879)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,1.22823,-66.0748)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,-21.53987,-21.33955)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> <g> <g> <path d=" M  40.87181 -42.67912 C  40.87181 -31.89165 32.12706 -23.1469 21.33958 -23.1469 C  10.55211 -23.1469 1.80736 -31.89165 1.80736 -42.67912 C  1.80736 -53.4666 10.55211 -62.21135 21.33958 -62.21135 C  32.12706 -62.21135 40.87181 -53.4666 40.87181 -42.67912 Z M  21.33958 -42.67912  " style=fill:none /> <g> <g transform=matrix(1.0,0.0,0.0,1.0,6.89511,-45.17912)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=-12.085510253906246 y=-50.166931152343736>(10,</text><text alignment-baseline=baseline fill=black font-family=cmr10 font-size=10 x=7.9145450592041 y=-50.166931152343736>0)</text></g></g> </g> </g> </g> </g> <path d=" M  9.92473 -19.84843 L  12.30873 -24.6171  " style=fill:none /> <g> <g transform=matrix(0.44896,-0.898,0.898,0.44896,12.30872,-24.61708)> <g> <g stroke-width=0.31999pt> <g stroke-dasharray=none stroke-dashoffset=0.0pt> <g stroke-linecap=round> <g stroke-linejoin=round> <path d=" M  -1.19998 1.59998 C  -1.09998 0.99998 0.0 0.09999 0.29999 0.0 C  0.0 -0.09999 -1.09998 -0.99998 -1.19998 -1.59998  " style=fill:none /> </g> </g> </g> </g> </g> </g> </g> <g> <g> <g transform=matrix(1.0,0.0,0.0,1.0,22.08975,-22.43929)> <g stroke=rgb(0.0%,0.0%,0.0%)> <g fill=rgb(0.0%,0.0%,0.0%)> <g transform="scale(-1,1) translate(-12.085510253906246,-50.166931152343736) scale(-1,-1)" stroke=none></g></g> </g> </g> </g> </g> </g> </g> </g> </g> </g> </g> </g></svg>
</div>
<p></p>
<p>Huh, weird size but whatever, it gets the idea across. Now this is where things get a little crazy. And where I had to do some manual testing to figure it out. Let's try putting together a table:</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>3</th>
<th>7</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>(3, 0)</td>
<td>(10, 10)</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>(7, 0)</td>
<td>(17, 17)</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td></td>
<td>(10, 0)</td>
</tr>
</tbody>
</table>
<p>The weird thing is how to actually calculate what goes in the cells. How do I calculate the corner? Well, first, just to be explicit, we "add" tuples with the following function:</p>
<p>$$ \begin{align} add(a, b) = (a[0] + b[0], a[0] + b[0] + a[1] + b[1]) \end{align} $$</p>
<p>Let's think back to our two trees above. We can either do $add((3, 0), (17, 17)) = (20, 37)$ or $add((10, 10), (10, 0)) = (20, 20)$ which is the solution. This might be obvious with the tree, and we might glance over it in the case of two cuts, but we need to dig deeper in the case of more cuts.</p>
<p>Let's try cuts at 4, 6, and 9 on a string of length 15.</p>
<p>Ok, so as usual, this leaves us with the consecutive segments: 4, 2, 3, 6. Our table looks like this after filling all the way to the 3rd diagonal:</p>
<table>
<thead>
<tr>
<th>i\j</th>
<th>4</th>
<th>2</th>
<th>3</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>(4, 0)</td>
<td>(6, 6)</td>
<td>(9, 14)</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>(2, 0)</td>
<td>(5, 5)</td>
<td>(11, 16)</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>(3, 0)</td>
<td>(9, 9)</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td>(6, 0)</td>
</tr>
</tbody>
</table>
<p>But what possibilities do we have for the corner now? Again, think back to the tree. Or really, the base nodes. Let me just define $f(i, j)$ to be the entry in the table, so we can avoid getting mixed up with the tuples. The equations we can use are $add(f(4, 3), f(6, 6))$, $add(f(4, 4), f(2, 6))$, and $add(f(4, 2), f(3, 6))$. The minimum turns out to be $add(f(4, 3), f(6, 6))$ which is $(15, 29)$. The minimum cost is 29.</p>
<p>Again, how did we figure out what we could add? Well we thought about the tree, but chances are our program won't have the luxury of looking at a tree (or we don't want to waste time writing something like that). You probably just need to stare at the table and draw some lines, as that's what I did, to find the pattern. Here is a nice image:</p>
<p><img alt=dptable src=/blobs/4/dptable.png></p>
<p>What you should notice is that for cells on the red diagonal, we calculated the value using cells that were a total of 2 units away from our target cell. For the blue diagonal, we considered cells that were a total of 3 units away, and for the green 4. With this, we now have a way to figure out what cells to use when calculating.</p>
<p>This problem's solution (if correct) is quite different from what I've gone through far. My guess (and then further searching) shows that my solution to this problem is quite different from the approach suggested on various websites. Those solutions define the problem as trying to minimize the cost of cutting a string for $i$ to $j$. I do see the parallels though between mine solution and that one.</p>
<p>Because this seems like a unique solution, let's take a small stab at the complexity here. We know there will be $(m) + (m - 1) + ... + 1$ cells. For $m$ cells (the initial diagonal) the cost is constant to fill each one, as there is only 1 case. However, as the diagonal increases, so do the number of cases. Refer to the previous image; the blue diagonal had 2 cases per cell and the green 3. Therefore we come out to something like this: $(1)(m) + (2)(m - 1) + ... (m)(1)$ calculations. The terms of that summation seem to be $O(m^2)$ and there are a total of $m$ terms, which leads to a $O(m^3)$ runtime.</p>
<p>A small thought I had afterwards: I'd like to believe that I knew I could have come up with the standard solution everywhere else uses, but realized that was a lot of inefficiency because there is no reason to consider splitting the string into subproblems where cuts are not invovled.</p>
<nav class=posts-nav_bottom>
<div class=posts-nav_before><a href=/./puzzles/3>&lt; randomized algorithms 1</a></div> <div class=posts-nav_after><a href=/./puzzles/5>divide and conquer 1 &gt;</a></div>
</nav>
<div class=commit-container>
<div class="commit-list de-emphasized">
<span>History:</span>
<details>
<summary>2020-12-23 - add exercise 5</summary>
<pre class=code-block><input id=code-block-5b50e89dfddf96baedc30c2dcc43ce863ad09cc2-1 type=checkbox><label for=code-block-5b50e89dfddf96baedc30c2dcc43ce863ad09cc2-1></label><code><span class=hljs-meta>@@ -158,2 +158,8 @@</span> terms of that summation seem to be $O(m^2)$ and there are a total of $m$ terms,
 leads to a $O(m^3)$ runtime.
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+A small thought I had afterwards: I&#x27;d like to believe that I knew I could have come</span>
<span class=hljs-addition>+up with the standard solution everywhere else uses, but realized that was a lot of</span>
<span class=hljs-addition>+inefficiency because there is no reason to consider splitting the string into subproblems</span>
<span class=hljs-addition>+where cuts are not invovled.</span>
 &lt;/p&gt;
</code></pre>
</details>
<details>
<summary>2020-12-19 - update exercise 3</summary>
<pre class=code-block><input id=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-1 type=checkbox><label for=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-1></label><code><span class=hljs-meta>@@ -26,4 +26,4 @@</span> baked into the lengths of the substrings. Let&#x27;s try it out on the example:
 &lt;br /&gt;
<span class=hljs-deletion>-We have substrings of length 3, 7, and 10 because we have cuts at 3 and 10. It</span>
<span class=hljs-deletion>-looks something like this:</span>
<span class=hljs-addition>+We have substrings of length 3, 7, and 10 because we have cuts at 3 and 10 and a</span>
<span class=hljs-addition>+total length of 20. It looks something like this:</span>
 &lt;br /&gt;
</code></pre>
<pre class=code-block><input id=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-2 type=checkbox><label for=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-2></label><code><span class=hljs-meta>@@ -33,4 +33,4 @@</span> looks something like this:
     \node (a) {3};
<span class=hljs-deletion>-    \node [left of = a] (b) {7};</span>
<span class=hljs-deletion>-    \node [left of = b] (c) {10};</span>
<span class=hljs-addition>+    \node [right of = a] (b) {7};</span>
<span class=hljs-addition>+    \node [right of = b] (c) {10};</span>
   \end{tikzpicture}
</code></pre>
<pre class=code-block><input id=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-3 type=checkbox><label for=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-3></label><code><span class=hljs-meta>@@ -93,10 +93,15 @@</span> The weird thing is how to actually calculate what goes in the cells. How do I ca
 the corner? Well, first, just to be explicit, we &quot;add&quot; tuples with the following
<span class=hljs-deletion>-function: $add(a, b) = (a[0] + b[0], a[0] + b[0] + a[1] + b[1])$. Let&#x27;s think back</span>
<span class=hljs-deletion>-to our two trees above. We can either do $add((3, 0), (17, 17)) = (20, 37)$ or</span>
<span class=hljs-deletion>-$add((10, 10), (10, 0)) = (20, 20)$ which is the solution. This might be obvious</span>
<span class=hljs-deletion>-with the tree, and we might glance over it in the case of two cuts, but we need</span>
<span class=hljs-deletion>-to dig deeper in the case of more cuts. Here&#x27;s another example:</span>
<span class=hljs-addition>+function:</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+\begin{align}</span>
<span class=hljs-addition>+  add(a, b) = (a[0] + b[0], a[0] + b[0] + a[1] + b[1])</span>
<span class=hljs-addition>+\end{align}</span>
<span class=hljs-addition>+$$</span>
<span class=hljs-addition>+Let&#x27;s think back to our two trees above. We can either do</span>
<span class=hljs-addition>+$add((3, 0), (17, 17)) = (20, 37)$ or $add((10, 10), (10, 0)) = (20, 20)$ which</span>
<span class=hljs-addition>+is the solution. This might be obvious with the tree, and we might glance over it</span>
<span class=hljs-addition>+in the case of two cuts, but we need to dig deeper in the case of more cuts.</span>
 &lt;br /&gt;
 &lt;br /&gt;
<span class=hljs-deletion>-Let&#x27;s try cuts at 4, 6, and 9.</span>
<span class=hljs-addition>+Let&#x27;s try cuts at 4, 6, and 9 on a string of length 15.</span>
 &lt;br /&gt;
</code></pre>
<pre class=code-block><input id=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-4 type=checkbox><label for=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-4></label><code><span class=hljs-meta>@@ -126,3 +131,3 @@</span> want to waste time writing something like that). You probably just need to stare
 at the table and draw some lines, as that&#x27;s what I did, to find the pattern. Here
<span class=hljs-deletion>-is a nice image.</span>
<span class=hljs-addition>+is a nice image:</span>
 &lt;br /&gt;
</code></pre>
<pre class=code-block><input id=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-5 type=checkbox><label for=code-block-b73568e9ca3afe619ee75d81fea1de71f6b07699-5></label><code><span class=hljs-meta>@@ -134,4 +139,4 @@</span> What you should notice is that for cells on the red diagonal, we calculated the
 using cells that were a total of 2 units away from our target cell. For the blue
<span class=hljs-deletion>-diagonal, we considered cells that were a total of 3 units away, and for the red</span>
<span class=hljs-deletion>-1. With this, we now have a way to figure out what cells to use when calculating.</span>
<span class=hljs-addition>+diagonal, we considered cells that were a total of 3 units away, and for the green</span>
<span class=hljs-addition>+4. With this, we now have a way to figure out what cells to use when calculating.</span>
 &lt;br /&gt;
</code></pre>
</details>
<details>
<summary>2020-12-18 - add exercise 4</summary>
<pre class=code-block><input id=code-block-50bea28a829f65bd4119d5088676e4cb36c6ed96-1 type=checkbox><label for=code-block-50bea28a829f65bd4119d5088676e4cb36c6ed96-1></label><code><span class=hljs-meta>@@ -0,0 +1,154 @@</span>
<span class=hljs-addition>+&lt;!-- markdownlint-disable MD041 --&gt;</span>
<span class=hljs-addition>+## Question 1</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+A certain string-processing language offers a primitive operation which splits a</span>
<span class=hljs-addition>+string into two pieces. Since this operation involves copying the original string,</span>
<span class=hljs-addition>+it takes $n$ units of time for a string of length $n$, regardless of the location</span>
<span class=hljs-addition>+of the cut. Suppose, now, that you want to break a string into many pieces. The order</span>
<span class=hljs-addition>+in which the breaks are made can affect the total running time. For example, if</span>
<span class=hljs-addition>+you want to cut a 20-character string at positions 3 and 10, then making the first</span>
<span class=hljs-addition>+cut at position 3 incurs a total cost of 20 + 17 = 37, while doing position 10 first</span>
<span class=hljs-addition>+has a better cost of 20 + 10 = 30.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Give a dynamic programming algorithm that, given the locations of $m$ cuts in a string</span>
<span class=hljs-addition>+of length $n$, finds the minimum cost of breaking the string into $m + 1$ pieces.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+So, I can&#x27;t think of a formula off the top of my head, and I&#x27;m not fully sure how</span>
<span class=hljs-addition>+the tree (I assume it&#x27;s a tree approach) will look. However, let&#x27;s try working the</span>
<span class=hljs-addition>+problem backwards; we have $m + 1$ substrings in order and we want to join them together</span>
<span class=hljs-addition>+while minimizing this cost. The cost to join 2 substrings $m_i$ and $m_{i + 1}$ is</span>
<span class=hljs-addition>+$\text{len}(m_i) + \text{len}(m_{i + 1})$. In this scenario, the cut locations are</span>
<span class=hljs-addition>+baked into the lengths of the substrings. Let&#x27;s try it out on the example:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+We have substrings of length 3, 7, and 10 because we have cuts at 3 and 10. It</span>
<span class=hljs-addition>+looks something like this:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node (a) {3};</span>
<span class=hljs-addition>+    \node [left of = a] (b) {7};</span>
<span class=hljs-addition>+    \node [left of = b] (c) {10};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+And we are looking for a way to join them. It is important to note that only neighboring</span>
<span class=hljs-addition>+nodes can be joined. We have two choices at this moment:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node {10}</span>
<span class=hljs-addition>+      child{ node (a) {3} edge from parent node[left, draw=none] {}}</span>
<span class=hljs-addition>+      child{ node (b) {7} edge from parent node[right, draw=none] {}};</span>
<span class=hljs-addition>+    \node [right of = b] (c) {10};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node {17}</span>
<span class=hljs-addition>+      child{ node (b) {7} edge from parent node[left, draw=none] {}}</span>
<span class=hljs-addition>+      child{ node (c) {10} edge from parent node[right, draw=none] {}};</span>
<span class=hljs-addition>+    \node [left of = b] (a) {3};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+We can also see various base cases here - when there is only 1 substring. However,</span>
<span class=hljs-addition>+one thing to note is that we also need to keep track of the total cost to reach that</span>
<span class=hljs-addition>+stage. If we were to go one step higher and reach 20, we realize that 20 is not the</span>
<span class=hljs-addition>+cost but rather the cost of the last step. Let&#x27;s see the example but we also keep</span>
<span class=hljs-addition>+track of the cost:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;script type=&quot;text/tikz&quot;&gt;</span>
<span class=hljs-addition>+  \begin{tikzpicture}[nodes={draw, circle, minimum size=0.75cm}, -&gt;]</span>
<span class=hljs-addition>+    \node {(20, 30)}</span>
<span class=hljs-addition>+      child{node {(10, 10)}</span>
<span class=hljs-addition>+        child{ node {(3, 0)} edge from parent node[left, draw=none] {}}</span>
<span class=hljs-addition>+        child{ node {(7, 0)} edge from parent node[right, draw=none] {}}</span>
<span class=hljs-addition>+        edge from parent node[left, draw=none] {}</span>
<span class=hljs-addition>+      }</span>
<span class=hljs-addition>+      child{node {(10, 0)} edge from parent node[right, draw=none] {}};</span>
<span class=hljs-addition>+  \end{tikzpicture}</span>
<span class=hljs-addition>+&lt;/script&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Huh, weird size but whatever, it gets the idea across. Now this is where things</span>
<span class=hljs-addition>+get a little crazy. And where I had to do some manual testing to figure it out.</span>
<span class=hljs-addition>+Let&#x27;s try putting together a table:</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  i\j  | 3      | 7        | 10       |</span>
<span class=hljs-addition>+| :---: | ------ | -------- | -------- |</span>
<span class=hljs-addition>+|   3   | (3, 0) | (10, 10) |          |</span>
<span class=hljs-addition>+|   7   |        | (7, 0)   | (17, 17) |</span>
<span class=hljs-addition>+|  10   |        |          | (10, 0)  |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+The weird thing is how to actually calculate what goes in the cells. How do I calculate</span>
<span class=hljs-addition>+the corner? Well, first, just to be explicit, we &quot;add&quot; tuples with the following</span>
<span class=hljs-addition>+function: $add(a, b) = (a[0] + b[0], a[0] + b[0] + a[1] + b[1])$. Let&#x27;s think back</span>
<span class=hljs-addition>+to our two trees above. We can either do $add((3, 0), (17, 17)) = (20, 37)$ or</span>
<span class=hljs-addition>+$add((10, 10), (10, 0)) = (20, 20)$ which is the solution. This might be obvious</span>
<span class=hljs-addition>+with the tree, and we might glance over it in the case of two cuts, but we need</span>
<span class=hljs-addition>+to dig deeper in the case of more cuts. Here&#x27;s another example:</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Let&#x27;s try cuts at 4, 6, and 9.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Ok, so as usual, this leaves us with the consecutive segments: 4, 2, 3, 6. Our</span>
<span class=hljs-addition>+table looks like this after filling all the way to the 3rd diagonal:</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+|  i\j  | 4      | 2      | 3       | 6        |</span>
<span class=hljs-addition>+| :---: | ------ | ------ | ------- | -------- |</span>
<span class=hljs-addition>+|   4   | (4, 0) | (6, 6) | (9, 14) |          |</span>
<span class=hljs-addition>+|   2   |        | (2, 0) | (5, 5)  | (11, 16) |</span>
<span class=hljs-addition>+|   3   |        |        | (3, 0)  | (9, 9)   |</span>
<span class=hljs-addition>+|   6   |        |        |         | (6, 0)   |</span>
<span class=hljs-addition>+</span>
<span class=hljs-addition>+&lt;p&gt;</span>
<span class=hljs-addition>+But what possibilities do we have for the corner now? Again, think back to the tree.</span>
<span class=hljs-addition>+Or really, the base nodes. Let me just define $f(i, j)$ to be the entry in the table,</span>
<span class=hljs-addition>+so we can avoid getting mixed up with the tuples. The equations we can use are</span>
<span class=hljs-addition>+$add(f(4, 3), f(6, 6))$, $add(f(4, 4), f(2, 6))$, and $add(f(4, 2), f(3, 6))$. The</span>
<span class=hljs-addition>+minimum turns out to be $add(f(4, 3), f(6, 6))$ which is $(15, 29)$. The minimum</span>
<span class=hljs-addition>+cost is 29.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Again, how did we figure out what we could add? Well we thought about the tree, but</span>
<span class=hljs-addition>+chances are our program won&#x27;t have the luxury of looking at a tree (or we don&#x27;t</span>
<span class=hljs-addition>+want to waste time writing something like that). You probably just need to stare</span>
<span class=hljs-addition>+at the table and draw some lines, as that&#x27;s what I did, to find the pattern. Here</span>
<span class=hljs-addition>+is a nice image.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;img src=&quot;/blobs/4/dptable.png&quot; /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+What you should notice is that for cells on the red diagonal, we calculated the value</span>
<span class=hljs-addition>+using cells that were a total of 2 units away from our target cell. For the blue</span>
<span class=hljs-addition>+diagonal, we considered cells that were a total of 3 units away, and for the red</span>
<span class=hljs-addition>+1. With this, we now have a way to figure out what cells to use when calculating.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+This problem&#x27;s solution (if correct) is quite different from what I&#x27;ve gone through</span>
<span class=hljs-addition>+far. My guess (and then further searching) shows that my solution to this problem</span>
<span class=hljs-addition>+is quite different from the approach suggested on various websites. Those solutions</span>
<span class=hljs-addition>+define the problem as trying to minimize the cost of cutting a string for $i$ to</span>
<span class=hljs-addition>+$j$. I do see the parallels though between mine solution and that one.</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+&lt;br /&gt;</span>
<span class=hljs-addition>+Because this seems like a unique solution, let&#x27;s take a small stab at the complexity</span>
<span class=hljs-addition>+here. We know there will be $(m) + (m - 1) + ... + 1$ cells. For $m$ cells (the</span>
<span class=hljs-addition>+initial diagonal) the cost is constant to fill each one, as there is only 1 case.</span>
<span class=hljs-addition>+However, as the diagonal increases, so do the number of cases. Refer to the previous</span>
<span class=hljs-addition>+image; the blue diagonal had 2 cases per cell and the green 3. Therefore we come</span>
<span class=hljs-addition>+out to something like this: $(1)(m) + (2)(m - 1) + ... (m)(1)$ calculations. The</span>
<span class=hljs-addition>+terms of that summation seem to be $O(m^2)$ and there are a total of $m$ terms, which</span>
<span class=hljs-addition>+leads to a $O(m^3)$ runtime.</span>
<span class=hljs-addition>+&lt;/p&gt;</span>
</code></pre>
</details>
</div>
</div>
</div>
<picture id=very-cute-picture><img onerror='load_backup_image("/scripts/cozy_reimu.bmp"),load_backup_image("/scripts/unamused_reimu.bmp")' srcset=reimu>
</picture>
</body>
</html>
