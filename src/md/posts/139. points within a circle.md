# points within a circle

While I was browsing through various job offerings, I noticed a comment on one
that, I assume, was an attempt to give candidates an edge by sharing a coding
interview question ahead of time. It looked straightforward yet interesting, so
I ended up thinking about it for a few minutes in bed before sleeping.

The gist of the question is:

You're given a set of points `(id1, x, y)` located at $(x, y)$ and queries
`(id2, x, y, r)` representing circles centered on $(x, y)$ with radius $r$.
Figure out which points should be returned for each query.

$$
\begin{tikzpicture}
  \draw (0, 0) -- (10, 0);
  \draw (0, 0) -- (0, 10);
  \draw (5, 5) circle (2.5);
  \draw (5, 5) -- (5, 7.5) node[midway, right] (cr) {$r$};
  \filldraw (5, 5) circle (0.05) node[below right] (cc) {$(x_c, y_c)$};
  \filldraw (3, 4) circle (0.05) node[below right] (p1) {$(x_1, y_1)$};
  \filldraw (7, 8) circle (0.05) node[below right] (p2) {$(x_2, y_2)$};
  \filldraw (1, 6) circle (0.05) node[below right] (p3) {$(x_3, y_3)$};
  \filldraw (7, 3) circle (0.05) node[below right] (p4) {$(x_4, y_4)$};
\end{tikzpicture}
$$

So I'll skip the "parse text into structured data" that you would probably have
to write for this, and skip ambiguities in the problem like how the example
weaved points and queries in the input and didn't specify if a query should
return all points or just the points that came before it in an input, and go
straight to various avenues of approach for the solution.

The first option is to do things the obvious way - when a query is made, filter
through all the points looking for one where $\Delta x^2 + \Delta y^2 \lt r^2$
or something like that.

But if you have a lot of points, then that doesn't sound good. If the queries
are repeated another simple optimization would be to cache the responses. The
caching idea lead me to another one which was pre-calculating the solution of
different areas and somehow figuring out which subareas make up a circle and
combining them for the response. I do not know how to implement that if
possible, though I think quad trees might provide guidance.

Going back to the issue of many points, I started thinking of ways to cut down
the candidate list from everything to less than everything. I then thought that
by ordering the data it might be possible to stop considering candidates when
one is outside the query as the rest would also be too far. For example, on a 1d
space using points and line (segments) instead of points and circles, if the
points are (an ordered) $1, 3, 4, 5, 10,...$, and our line segment is centered
around 4 with length 2 meaning it spans $[2, 6]$, then as we iterate through our
ordered list, then once we see that $10$ is outside of $[2, 6]$, we no longer
have to keep going. I did not think of how to order the points for this idea to
apply to this problem, if possible.

$$
\begin{tikzpicture}
  \draw (0, 0) -- (15, 0);
  \filldraw (0, 0) circle (0.075) node[below] (s) {$0$};
  \filldraw (1, 0) circle (0.05) node[below] (p1) {$1$};
  \filldraw[red] (3, 0) circle (0.05) node[below] (p2) {$3$};
  \filldraw[red] (4, 0) circle (0.05) node[below] (p3) {$4$};
  \filldraw[red] (5, 0) circle (0.05) node[below] (p4) {$5$};
  \filldraw (10, 0) circle (0.05) node[below] (p5) {$10$};
  \filldraw (15, 0) circle (0.075) node[below] (e) {$15$};

  \draw (2, 1) -- (6, 1);
  \filldraw (2, 1) circle (0.05) node[below] (ls) {$2$};
  \filldraw (6, 1) circle (0.05) node[below] (le) {$6$};
\end{tikzpicture}
$$

However, looking at the 1d idea, we can also use it to cut off earlier
candidates, since we know it has to be at least 2. In fact, we know the entire
solution is everything between $[2, 6]$ so if we grab that range from our
ordered points then that's the solution. We can extend this to the 2d space in
the problem by doing this for the x and y dimensions - for a query with radius
$(x, y, r)$ we can look at ranges $[x - r, x + r]$ and $[y - r, y + r]$ and
using the intersection of those members for candidates. Conceptually this is
drawing a square that bounds the circle and only picking points within them
where things that fall in the corners will be filtered out through the normal
process. The ranges can be found efficiently using b trees or range trees.

<!-- markdownlint-disable line-length -->

$$
\begin{tikzpicture}
  \draw (0, 0) -- (10, 0);
  \draw (0, 0) -- (0, 10);
  \draw (5, 5) circle (2.5);
  \draw (5, 5) -- (5, 7.5) node[midway, right ] (cr) {$r$};
  \filldraw (5, 5) circle (0.05) node[below right] (cc) {$(x_c, y_c)$};
  \filldraw (3, 4) circle (0.05) node[below right] (p1) {$(x_1, y_1)$};
  \filldraw (7, 8) circle (0.05) node[below left] (p2) {$(x_2, y_2)$};
  \filldraw (1, 6) circle (0.05) node[below right] (p3) {$(x_3, y_3)$};
  \filldraw (7, 3) circle (0.05) node[below left] (p4) {$(x_4, y_4)$};
  \draw[red, thick] (2.5, 0) -- (2.5, 10);
  \draw[red, thick] (7.5, 0) -- (7.5, 10);
  \draw[cyan, thick] (0, 2.5) -- (10, 2.5);
  \draw[cyan, thick] (0, 7.5) -- (10, 7.5);
  \draw[violet, very thick] (2.5, 2.5) -- (2.5, 7.5) -- (7.5, 7.5) -- (7.5, 2.5) -- (2.5, 2.5);
  \filldraw[violet] (2.5, 7.5) circle (0.075) node[below left] (c1) {$(x_c - r, y_c + r)$};
  \filldraw[violet] (2.5, 2.5) circle (0.075) node[below left] (c2) {$(x_c - r, y_c - r)$};
  \filldraw[violet] (7.5, 7.5) circle (0.075) node[below right] (c3) {$(x_c + r, y_c + r)$};
  \filldraw[violet] (7.5, 2.5) circle (0.075) node[below right] (c4) {$(x_c + r, y_c - r)$};
\end{tikzpicture}
$$

<!-- markdownlint-enable line-length -->

I liked this idea, and thought it was reasonable. The one final idea I
considered for the ordering points approach was to use polar coordinates for the
points, since they already contain the radius though from the origin. I also
could not think of any way to apply this.

Like all interview questions, I'm always left with the question of whether this
is the "official" solution or not. Fortunately, this appears to be a common
interview question and various solutions are online, including bounding squares,
bounding diamonds, and a k-d tree which I was unfamiliar with... oh it's just
another version of a tree that partitions space, so maybe it's the proper
version of the quad tree solution.
