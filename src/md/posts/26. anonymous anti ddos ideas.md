# anonymous anti ddos ideas

A lot of the stuff I make ends up missing functionality like actual user signup
and authentication through some involved process e.g. verifying an email address.
If you're running an api and you let people make requests anonymously, then you
run a much higher risk of getting ddosed.

I've spent some time yesterday thinking about how to handle this, and came up with
a few ideas based on some assumptions. I'll go through them in order, because if
one of my assumptions are wrong (due to a lack of understanding or something else),
then the entire thing falls apart and you might as well stop reading.

## why is it easier to ddos something without validation or authentication?

This is the category my stuff falls under - no verification or signups - or
at most a very simple sign up with no kind of verification. Every time I write something
along the lines of this, I just imagine someone recording the requests, automating
them, and hammering my website (unlikely because no one uses my websites).

With validation, users will probably have to have an actual email set up and
click a verification link after signing up - this requires a lot more effort than
not having it. Admittedly, this part is also automatable somewhat - temporary
email addresses are a thing, or you can just have your own domains.

We just need to somehow make the user have to put more effort in when making a request
anonymously (whether they know it or not).

## problems that are hard to solve but easy to check

Most (all?) authentication has the server check some provided key to see if it is
valid. The key is also generated by the server but only once the user is validated.
In our case, we assume there is no validation - so the server just generates a key
whenever it's asked for. However, this means that asking for a key is not protected
from anonymous requests. This means that we need to move the key generation to the
client's side.

We want to make the generation take more effort than normal, but also allow the key
to be easily checked by the server to determine if it's valid or not. The first idea
that came into my head is something like solving polynomial equations. For humans,
solving a polynomial is a little difficulty, but checking the answer just requires
plugging it in and checking for equality. I'm not sure if this requires "effort"
from a computer, but there are numerical methods to get close approximations which
might be good enough to fool the validator so this might not work.

### NP-complete problems

It just so happens that NP-complete problems might be what I was looking for -
verifiable in polynomial time (relatively quickly), but solvable in a much more complex
time.

One of the simplest ones to understand is the boolean satisfiability problem which
is where you are given a boolean formula and need to find out whether it can evaluate
to true or not. You end up having to true combinations of true and false until you
find the solution. When the server receives the proposed solution, checking it is
as simple as plugging the solution into the formula.

The main issue with this problem is it's hard to validate if the formula is not
satisfiable because that requires checking all combinations, so you want a problem
that doesn't have this issue - maybe something like a problem covered by the four
color theorem.

### captcha

I think captchas might be one example of this - proper captchas are hard for computers
to solve but easy to validate because the answer is either already determined ahead
of time when generated or just depends on what other humans answer, in which case
you need a human doing work.

### blockchain?

I hate to be that guy (especially when I know nothing about blockchain) but if I
understand correctly, there is a lot of processing power when mining crypto -
so they must be solving some hard problem, and then they come up with proof of work
which is supposedly simple to validate.

## guess at actual implementation

Let's assume we go with the four color theorem approach. What you need is a function
that takes in some seed that generates a graph. This function is present on both
server/client so the server can also recreate the graph when the client passes the
seed and solution. The client then spends time trying to color in the graph and attaches
the solution to the request.

The seed should take the current time and data being sent into account so that the
generated graph is unique (more or less) to the request. This helps prevent reusing
the calculated solution for future requests. Of course, this means the time of the
request also has to be sent along - in which case the server would also have to
validate the time with the actual time.

What happens if it takes too long to solve the problem? Then the server would most
likely discard the request... There are definitely some other things to think about
on top of the fact that this might just be a dumb idea - everything is slower, is
the validation actually quick enough? It might be possible to have the client slowly
calculate various solutions over time and use those for authentication.

## conclusion

We shift most of the authentication work to the client. We also take advantage of
problems that are hard to find a solution for, but whose solutions are easy to validate
to handicap clients from sending too many requests at a time.

Someone's trying to ddos you? Good luck because each request requires solving a specific
NP-complete problem tailored to that request.

Is this even a feasible approach? Probably not, but thinking about it was entertaining
for me.

### Later update

I ended up looking at some stuff about proof of work for curiosity's sake and the
concept came up around 1993 specifically to combat spam/junk mail... so I guess
it supports the idea that this could be a valid countermeasure against ddos attacks.
The difference is that emails are sent out much less frequently compared to requests
most likely so this approach's effects (takes more computing power) might be more
pronounced in this use case.

It's pretty cool when you think up some random ideas only for them to already exist
and be implemented in various places.
