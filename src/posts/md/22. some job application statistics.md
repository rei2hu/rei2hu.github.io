# some job application statistics

This is a somewhat public record of my job applications and responses for a period
of job searches.

Dates include times so that even if two things happened on the same day they wouldn't
necessarily encrypt to the same value. Well there is also the iv so it should look
unique anyways as far as I know.

The key located as the `exportedKey` variable isn't the correct key. Most data will
be encrypted until I find a job or a long enough time has passed.

<!-- markdownlint-disable line-length-->
<table>
  <thead>
    <tr>
      <th>company</th>
      <th>requirements</th>
      <th>nice to haves</th>
      <th>application date</th>
      <th>1st reply date</th>
      <th>rejection date</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>zOVkjA4pdwUqZa41I6StuwPriKsxlSwhZ3m1og==~118,90,104,4,226,28,13,159,134,14,50,48</td>
      <td>
        req1 ✔<br/>
        req2 ✖<br/>
        extremely long lines and stuff means html here
      </td>
      <td></td>
      <td>empty to the left</td>
      <td>this is just</td>
      <td>a test row</td>
    </tr>
  </tbody>
</table>

<script>
// placeholder key to be updated
const exportedKey = {
    "alg": "A256GCM",
    "ext": true,
    "k": "rTESqH1AqI-lBJ5SdQcCRVxIMV-LiLYnA61ipt6Bq2E",
    "key_ops": [
      "encrypt",
      "decrypt"
    ],
    "kty": "oct"
};

async function decrypt(val, key) {
  // ~ isnt used in b64
  const [b64encoded, iv] = val.split("~");
  const encrypted = atob(b64encoded);
  const bytes = Uint8Array.from(
    encrypted.split("").map((c) => c.charCodeAt(0))
  );
  const result = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: Uint8Array.from(iv.split(",")) },
    key,
    bytes.buffer
  );
  return new TextDecoder().decode(result);
}

document.addEventListener("DOMContentLoaded", async () => {
  // try {
    const key = await window.crypto.subtle.importKey(
      "jwk",
      exportedKey,
      { name: "AES-GCM" },
      true,
      ["encrypt", "decrypt"]
    );
    const table = document.querySelector("table");
    const [
      {
        children: [header],
      },
      {
        children: [...rows],
      },
    ] = [...table.children];
    const columnNames = [...header.children].map((child) => child.innerHTML);
    const requirementsIdx = columnNames.indexOf("requirements");

    rows.forEach((row) => {
      [...row.children].forEach(async (rowCell, i) => {
        if (i === requirementsIdx) return;
        try {
          rowCell.innerHTML = await decrypt(rowCell.innerHTML, key);
        } catch {
          // failed to decrypt
          rowCell.style.color = "red";
          rowCell.innerHTML = `${rowCell.innerHTML.slice(0, 10)}${rowCell.innerHTML.length > 10 ? "..." : ""}\n (encrypted or undecryptable)`;
        }
      });
    });
  // } catch {
  //   // probably no key...
  // }
});
</script>
<!-- markdownlint-enable line-length-->
